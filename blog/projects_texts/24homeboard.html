<!DOCTYPE html>
<html>
<head>

<link rel="icon" href="/favicon.ico" type="image/x-icon"/>
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<title>Homeboard Nico Brailovsky's thought repository</title>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/style.css">
</head>

<body>

<div id="siteheader">
  <h1>Nico Brailovsky's thought repository</h1>

<div class="nav tabs is-full">
  <a class="is-center" href="/blog/index.html">Blog</a>
  <a class="is-center"
     href="https://github.com/search?type=code&q=repo%3Anicolasbrailo%2Fnicolasbrailo.github.io%20"
     onclick="togglesearch(); return false">Site search</a>
  <a class="is-center" href="/blog/projects_texts">Projects & Texts</a>
  <a class="is-center" href="/blog/history.html">Archive</a>
  <a class="is-center" href="/blog/aboutme.html">About</a>
</div>

<form id="sitesearch" class="nav tabs is-full is-hidden">
  <input type="text" id="sitesearch_q"/>
  <button type="submit">Search</button>
</form>

</div>

<div id="content" class="language-clike">
<h2 name="homeboard">Homeboard</h2>

<div class="post_metadata">
Post by Nico Brailovsky @ 2024-07-20 |
  <a href="/blog/projects_texts/24homeboard.html">Permalink</a>  |
  <a href="https://github.com/nicolasbrailo/nicolasbrailo.github.io/issues/new?title=Comment@md_blog/projects_texts/24homeboard.md&body=I%20have%20a%20comment!">Leave a comment</a>
</div>

<div class="post">
<p>TODO: Write about the project</p>
<hr />
<h2><a href="/blog/2024/0630_HouseboardP0.html">Houseboard P0: PP0</a><a name="houseboardp0pp0blog20240630_houseboardp0.html"></a></h2>
<p>Published 2024-06-30</p>
<p>I have a <a href="https://github.com/nicolasbrailo/BatiCasa">ton of unnecessary home automation</a>, but I'm lacking some kind of house board: a quick way of getting info before leaving (like weather, or transport conditions), leaving messages (don't forget to pick up kids from school) or just a shopping list. Sensible people would look at readily available digital signage solutions. Of course I didn't do that, instead decided to build my own.</p>
<p>I settled for a quick list of requirements to guide the project: Linux based, running off power-over-ethernet, with net-boot and 100% locally hosted. How hard can that be?</p>
<p>The first step to design my houseboard was searching for a panel. Here is a capture of the moment it failed:</p>
<p><a href="/blog_img/0630_HouseboardP0/1PanelBoardFail.jpg"><img alt="" src="/blog_img/0630_HouseboardP0/1PanelBoardFail.jpg" /></a></p>
<p>Turns out that scoring a random replacement panel for a laptop and trying to pair that with a random controller board works well in theory but needs a lot of luck. Starting with a cheapish £40 LCD panel with an eDP connector, I got an HDMI-to-eDP board. My panel and my board didn't like each other, so all I got was backlight, and that is not very useful unless you only need to display binary information.</p>
<p>Since ordering and shipping a different panel controller board would take a few weeks, I decided to change my strategy: my P0 would be changed to a Prototype-Prototype-0 (PP0), using a similar platform to let me start working on the software and sensors, while I figured the way to control a panel. Here is Houseboard PP0, in all it's glory:</p>
<p><a href="/blog_img/0630_HouseboardP0/2PP0.jpg"><img alt="" src="/blog_img/0630_HouseboardP0/2PP0.jpg" /></a></p>
<p>I got a USB-powered touchscreen, which is powered by a RaspberryPi 4. The RPI itself is powered over PoE, and there is an HDMI connection between the Rpi and the screen, and a secondary USB connection to get touch screen support. The PoE adapter is barely capable of powering the screen AND the Rpi: if I turn the brightness of the screen to 100%, the system will reset.</p>
<p>And with a few sensors (a PIR + mmWave):</p>
<p><a href="/blog_img/0630_HouseboardP0/3Sensors.jpg"><img alt="" src="/blog_img/0630_HouseboardP0/3Sensors.jpg" /></a></p>
<p>It's not going to win any design prizes, but it works</p>
<p><a href="/blog_img/0630_HouseboardP0/4Running.jpg"><img alt="" src="/blog_img/0630_HouseboardP0/4Running.jpg" /></a></p>
<p>While eventually I did end up solving my LCD panel woes, Houseboard PP0 let me start building some software for the houseboard quickly:</p>
<ol>
<li>A <a href="https://github.com/nicolasbrailo/swayimg">Wayland based image display</a> built on top of Swayimage; to show a gallery of pictures when there is no other info to show</li>
<li>A <a href="https://github.com/nicolasbrailo/pipresencemon">presence service</a> (to determine when there are humans nearby, based on PIR and mmWave sensors).</li>
</ol>
<h2>BoM for Houseboard PP0<a name="bomforhouseboardpp0"></a></h2>
<ul>
<li>A RaspberryPi 4 (any Pi will do, but having a bunch of USB ports makes this project a lot simpler)</li>
<li>A USB powered screen. I went for a 14'' 1080p 1920x1080, and with the PoE constrain that's probably as big as it's feasible. My browsing history says I got this one: https://www.amazon.co.uk/dp/B0CB5FWGT8</li>
<li>PoE splitter (USBC + ETH out, 5v 4A) - Look for the adapter with largest power rating you can, a cheap one won't work. I went for this one: https://www.amazon.co.uk/dp/B0CHW5K5F4</li>
<li><a href="https://thepihut.com/products/pir-motion-sensor-module">PIR sensor</a> (NB VCC=5v, connect to Pin4, GND Pin6, OUT Pin17)</li>
<li><a href="https://thepihut.com/products/breadboard-friendly-mini-pir-motion-sensor-with-3-pin-header">Smaller PIR sensor</a> (VCC=5v Pin4, GND Pin6, OUT Pin17)</li>
</ul>
<h2>Useful references<a name="usefulreferences"></a></h2>
<ul>
<li><a href="https://pi4j.com/1.2/pins/model-3b-rev1.html">Pi GPIO pins</a></li>
<li><a href="https://images.theengineeringprojects.com/image/webp/2021/03/raspberry-pi-zero-5.png.webp?ssl=1">PI Zero pins</a></li>
</ul>
<hr />
<h2><a href="/blog/2024/0707_HouseboardHdmiToEdp.html">Houseboard P0: HDMI to eDP</a><a name="houseboardp0hdmitoedpblog20240707_houseboardhdmitoedp.html"></a></h2>
<p>Published 2024-07-07</p>
<p>Minor victory in my quest to build a houseboard based on a Linux-PoE-netboot-RaspberryPi-etc: I figured out how to run my own LCD panel.</p>
<p><a href="/blog_img/0707_HouseboardHdmiToEdp/1DPtoeDP.jpg"><img alt="" src="/blog_img/0707_HouseboardHdmiToEdp/1DPtoeDP.jpg" /></a></p>
<p>The first step was verifying my panel worked. For this, I used a display port to eDP converter. Turns out eDP is basically DP, but over a ribbon cable. There are some cheap boards, <a href="https://www.aliexpress.com/item/1005006914739674.html">for example</a>, that do this - searching for "DP to eDP" or "display port to eDP" will yield a high number of vendors. The key part is matching the ribbon type of the panel you need to drive (30 or 40 pins).</p>
<p>Unfortunatelly, single-board-computers (like the RaspberryPi) don't have DP, despite DP being better than HDMI in every way. The cost of adding a DP connector seems to be high and mosty in licenses, not necessarily in components, so SBCs don't do it. This meant that getting my expensive GPU to use my cheap panel wasn't good for much beyond knowing the panel works.</p>
<p>Fortunatelly, I managed to find a board that liked my panel:</p>
<p><a href="/blog_img/0707_HouseboardHdmiToEdp/2HDMItoeDP.jpg"><img alt="" src="/blog_img/0707_HouseboardHdmiToEdp/2HDMItoeDP.jpg" /></a></p>
<p>I got a "<a href="https://www.aliexpress.com/item/32968710965.html">PCB-800807V6-1HDMI-EDP 30PIN LCD driver board</a>", which comes at about £10 and supports multiple resolutions. This was a nice lucky find, and it unblocked the build of HouseboardP0, which I'll document in some other entry.</p>
<hr />
<h2><a href="/blog/2024/0714_StonebakedMargheritaHomeboard.html">Homeboard P0: Stonebaked Margherita</a><a name="homeboardp0stonebakedmargheritablog20240714_stonebakedmargheritahomeboard.html"></a></h2>
<p>Published 2024-07-14</p>
<p><strong>Homeboard P0 has been built!!1</strong></p>
<p>After figuring out <a href="/blog/2024/0707_HouseboardHdmiToEdp.html">how to run my own LCD panel</a>, it was just a question of buying the right cables. I wanted to build a homeboard, and I thought I'd spend a ton of time writing cool software. Turns out 90% of the project is a game of "did I buy the right cable". Eventually I did end up with enough cables to build this monstrosity:</p>
<p><a href="/blog_img/0714_HomeboardP0/1PanelTest.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/1PanelTest.jpg" /></a></p>
<p>You are admiring a:</p>
<ul>
<li>Raspberry Pi zero,</li>
<li>Powered over ethernet, with a PoE adapter</li>
<li>The Raspberry Pi Zero powers the LCD controller board</li>
<li>But the controller board needs 12V, so there is a DC-DC board that bumps the 5V from the RaspberryPi to the 12V the board needs.</li>
</ul>
<p>(Full list of materials further down, so you don't need to hunt all of these)</p>
<p>Here the glorious moment everything is connected together, and actually boots an OS:</p>
<p><a href="/blog_img/0714_HomeboardP0/2Boots.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/2Boots.jpg" /></a></p>
<p>Of course at this point I realized the weak point of my design is on the mechanical linkage between the different boards. To tame this quite literally unwieldy hodgepodge of cables, I ate a pizza:</p>
<p><a href="/blog_img/0714_HomeboardP0/3Mechanical.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/3Mechanical.jpg" /></a></p>
<p>Using the cardboard box of a pizza, some ducktape and a few M2 screws, I built a beautiful hack mount for all my boards, which let me move the assembly around for tests. This was enough for quick power checks, but pizza box cardboard isn't a very durable material. I upgraded to a full frame:</p>
<p><a href="/blog_img/0714_HomeboardP0/4Framing.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/4Framing.jpg" /></a></p>
<p>This is an Ikea picture frame, with an LCD screen tapped to the front and a hole in the back for the eDP connector. Everything mounted together:</p>
<p><a href="/blog_img/0714_HomeboardP0/5BoardMount.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/5BoardMount.jpg" /></a></p>
<p>And the glorious, glorious first boot of the Stonebaked Margherita Homeboard P0:</p>
<p><a href="/blog_img/0714_HomeboardP0/6FirstBoot.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/6FirstBoot.jpg" /></a></p>
<p>Of course at this stage the only thing the Houseboard P0 does is boot. An achievement, but not too useful. Next up, I'll make it do something. Possibly crash.</p>
<h2>BoM<a name="bom"></a></h2>
<ul>
<li>Pi Zero (not W, but W works too)</li>
<li><a href="https://www.amazon.co.uk/dp/B0742D2718">LCD panel</a></li>
<li><a href="https://www.aliexpress.com/item/32968710965.html">HDMI to eDP board</a></li>
<li><a href="https://thepihut.com/products/poe-to-micro-usb-adapter-for-pi-zero-ethernet-power-ieee-802-3af-compliant">PoE adapter</a></li>
<li><a href="https://www.amazon.co.uk/dp/B08F7SXC7S?psc=1&amp;ref=ppx_yo2ov_dt_b_product_details">M2 Screws</a></li>
<li><a href="https://www.amazon.co.uk/Step-up-Supply-Adjustable-Converter-4-5V-32V/dp/B075JQTPX6?">Step up board DC-DC 5v to 12V</a></li>
<li><a href="https://www.amazon.co.uk/dp/B08F7SXC7S">M2 Screws</a></li>
<li><a href="https://thepihut.com/collections/jumper-wires">Jumper wires</a> (get a mix of F/F, M/F and M/M)</li>
<li><a href="https://www.ikea.com/gb/en/p/ribba-frame-white-00268876/">An Ikea Ribba picture frame</a></li>
<li>Pizza. Margherita not required.</li>
<li>Mini HDMI to HDMI</li>
</ul>
<p>Optionals:</p>
<ul>
<li><a href="https://www.amazon.co.uk/gp/product/B0B7RHPMT7/ref=ppx_yo_dt_b_search_asin_title?ie=UTF8&amp;psc=1">UART</a> - to figure out why things don't boot, or to <a href="/blog/2024/0615_LD2410SmmWaveSensor.html">debug sensors</a></li>
<li>Regulable power source 3 to 30V - useful to debug power to elements in isolation</li>
<li><a href="https://www.aliexpress.com/i/1005006282168742.html">HLK-LD2410S 24G mmWave sensor</a> <a href="https://drive.google.com/file/d/1CYgZTTEkZoo29QDd8V-qMWQCiwLFjlw1/view">Manual</a> - not used yet, but soon</li>
</ul>
<h2>Useful references<a name="usefulreferences"></a></h2>
<ul>
<li><a href="https://pi4j.com/1.2/pins/model-3b-rev1.html">Pi GPIO pins</a></li>
<li><a href="https://images.theengineeringprojects.com/image/webp/2021/03/raspberry-pi-zero-5.png.webp?ssl=1">PI Zero pins</a></li>
</ul>
<hr />
<h2><a href="/blog/2024/0718_SonebakedMargheritaPictureFrame.html">Homeboard P0: Stonebaked Margherita Picture frame</a><a name="homeboardp0stonebakedmargheritapictureframeblog20240718_sonebakedmargheritapictureframe.html"></a></h2>
<p>Published 2024-07-18</p>
<p>With my homeboard booting up, it's time to make it show something. Some day I'll build a net-boot capable system, but until then I'd like to have it do something, even if it's by installing a few services by hand.</p>
<p><a href="/blog_img/0714_HomeboardP0/6FirstBoot.jpg"><img alt="" src="/blog_img/0714_HomeboardP0/6FirstBoot.jpg" /></a></p>
<h2>SD bootstrap<a name="sdbootstrap"></a></h2>
<p>[Feb 25 edit: added this section]</p>
<p>An Rpi Zero won't do much without one, so, starting with a base Raspbian Bookworm for Rpi Zero (32 bit), with no GUI:</p>
<ul>
<li><a href="https://www.raspberrypi.com/software/operating-systems/">Download an ISO</a> compatible with the board</li>
<li><code>sudo dd of=/dev/sdX if=./XXXX.img bs=8M status=progress</code></li>
<li>Mount sd card, then</li>
<li>Enable ssh: <code>cd /media/$USER/bootfs &amp;&amp; touch ssh &amp;&amp; touch ssh.txt</code></li>
<li><a href="https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-a-user">Create user (headless)</a>: <code>echo username:password &gt; /media/$USER/bootfs/userconf.txt</code></li>
</ul>
<p>These steps will give you an sd card that should boot and automatically connect to an eth connection (not wifi, of course), and let you ssh into the device to continue the setup. No need to hook up a keyboard.</p>
<h2>First boot<a name="firstboot"></a></h2>
<p>Optional: UART is useful to debug the first boot, but if the SD bootstrap was successful everything should just work.</p>
<ul>
<li>Debug why the system doesn't boot, as with any new install</li>
<li>UART into the system, then enable SSH (because the USB ports are hard to reach to connect a keyboard)</li>
<li>Disconnect UART, reconnect sensors, login over SSH</li>
<li>apt-get update, upgrade, etc...</li>
</ul>
<h2>Prepare Wayland<a name="preparewayland"></a></h2>
<p>Raspbian Bookworm 32bit doesn't have support for Wayland out of the box. To enable:</p>
<ul>
<li>Add this magic to /boot/firmware/config.txt</li>
</ul>
<pre lang="bash"><code class="language-bash" lang="bash">dtoverlay=vc4-kms-v3d
gpu_mem=128
</code></pre>
<ul>
<li>/boot/firmware/cmdline.txt needs to have <code>wayland=on</code></li>
<li><code>sudo apt-get install mesa-utils-bin wayfire seatd</code> - seatd is required to manage sessions, otherwise wayfire will complain it can't open a terminal.</li>
<li><code>sudo usermod -aG tty username</code> - I'm not sure if this is required. Try to skip it and see what happens. Let me know if you do.</li>
<li>reboot</li>
<li>After booting up, it should be possible to run <code>wayfire</code> in a terminal; an empty Wayland screen (with a cursor) should show up</li>
</ul>
<h2>Wayfire as a service<a name="wayfireasaservice"></a></h2>
<p>With everything "working", we can make Wayfire a system service, so it will start at boot:</p>
<p>Add this to <code>/etc/systemd/system/wayfire.service</code> (change the user name, and you may want to change the runtime dir too):</p>
<pre lang="config"><code class="language-config" lang="config">[Unit]
Description=wayfire
After=multi-user.target
[Service]
Environment=XDG_RUNTIME_DIR=/run/user/1000
ExecStart=wayfire
StandardOutput=inherit
StandardError=inherit
Restart=always
RestartSec=10s
User=batman
[Install]
WantedBy=multi-user.target
</code></pre>
<p>Now enable the service</p>
<ul>
<li><code>sudo systemctl daemon-reload</code></li>
<li><code>sudo systemctl enable wayfire</code></li>
</ul>
<p>Use this on your next reboot to find out why things are broken: <code>journalctl --follow --unit wayfire</code></p>
<p>Note: wayfire seems to crash a few times on startup. I guess there is a service dependency I haven't found yet, but as long as it's set to <code>Restart=Always</code> it should eventually come up.</p>
<h2>Screen rotation<a name="screenrotation"></a></h2>
<p>Because of the way the flex cable is fed to the HDMI-to-eDP board, the screen may end up rotated 180 degrees. You may also want a portrait picture frame, instead of a landscape one. To rotate Wayland:</p>
<ol>
<li>Do <code>kmsprint</code> or <code>kmsprint -m</code></li>
<li>Look for the name of the screen, eg HDMI-A-1</li>
<li>Look for the mode, eg 1920x1080@60.00</li>
<li>Create this in ~/.config/wayfire.ini, replacing the values found above for your setup</li>
</ol>
<pre lang="bash"><code class="language-bash" lang="bash">[output:HDMI-A-1]
mode = 1920X1080@60.00
position = 0,0
transform = 90
</code></pre>
<p>~~No need to reboot Wayfire, it should pick up the changes and fix itself immediately. I think.~~ You'll need to <code>sudo systemctl restart wayfire</code> to see the changes.</p>
<h2>swayimg<a name="swayimg"></a></h2>
<p>With a GUI, it's time to show a picture. I <a href="https://github.com/nicolasbrailo/swayimg">hacked swayimg to load pictures from a local server</a>, plus a few other useful features to make it more usable in a RpiW, like consuming less memory than default, and porting to 32 bits. To install dependencies:</p>
<pre lang="bash"><code class="language-bash" lang="bash">sudo apt-get install libcurl git ninja-build meson
sudo apt-get install libcurl4-openssl-dev
sudo apt-get install libwayland-dev wayland-protocols
sudo apt-get install libjson-c-dev libxkbcommon-dev libfontconfig-dev libjpeg-dev
</code></pre>
<p>To build: [Yes, this is building swayimg in our target. This is horrible and will take a long time, so be prepared for a long coffee break. Some day I'll setup a crosscompiler].</p>
<pre lang="bash"><code class="language-bash" lang="bash">git clone https://github.com/nicolasbrailo/swayimg.git
meson setup [build|--wipe build]
ninja -C build
</code></pre>
<p>To start:</p>
<ul>
<li>Launch Wayfire in a terminal</li>
<li>In another terminal:</li>
<li><code>WAYLAND_DISPLAY="wayland-1" DISPLAY="" /home/batman/swayimg/build/swayimg</code></li>
</ul>
<p>Check that nothing crashes too much.</p>
<h2>P0 picture frame<a name="p0pictureframe"></a></h2>
<p>Also this to <code>/etc/systemd/system/ambience.service</code> (also change the user name. Or make a new user):</p>
<pre lang="config"><code class="language-config" lang="config">[Unit]
Description=ambience
After=multi-user.target
[Service]
Environment=XDG_RUNTIME_DIR=/run/user/1000 WAYLAND_DISPLAY="wayland-1" DISPLAY=""
ExecStart=/home/batman/swayimg/build/swayimg
StandardOutput=inherit
StandardError=inherit
Restart=always
RestartSec=3s
User=batman
[Install]
WantedBy=multi-user.target
</code></pre>
<p>Then:</p>
<ul>
<li><code>sudo systemctl daemon-reload</code></li>
<li>In a terminal: <code>journalctl --follow --unit wayfire --unit ambience</code></li>
<li>In another terminal:</li>
</ul>
<pre lang="bash"><code class="language-bash" lang="bash">sudo systemctl enable ambience
sudo systemctl restart ambience
</code></pre>
<p>Next time you boot up, the Stonebaked Margherita P0 frame should behave like a picture frame.</p>
<hr />
<h2><a href="/blog/2024/0909_wwwslide.html">Homeboard: wwwslide</a><a name="homeboardwwwslideblog20240909_wwwslide.html"></a></h2>
<p>Published 2024-09-10</p>
<p>Homeboard hasn't seen much progress during the holidays, except for a small but useful piece of software: I created <a href="https://github.com/nicolasbrailo/wwwslide">a hacky way to serve pictures over a web interface</a>. This is a fairly fundamental piece of infrastructure for my homeboard project; most of the time these will be displaying some ambient information, but most of the screen's real estate will be used to show my (reasonably large and decades spanning) personal picture collection.</p>
<p><a href="https://github.com/nicolasbrailo/wwwslide">wwwslide</a> looks like this:</p>
<p><a href="/blog_img/1009_wwwslide.jpg"><img alt="" src="/blog_img/1009_wwwslide.jpg" /></a></p>
<p>From the readme:</p>
<blockquote>
<p>wwwslide is a client/server for LAN slideshows. If you have a large picture collection and want a way to display them in multiple places, wwwslide server will create a web interface to retrieve random pictures from a single url. The web client can display these pictures, but there is no reason to use the included client: you could curl wwwslide and pipe it to an image viewer.</p>
<p>wwwslide has a server that can be pointed to a local pictures directory. It expects that pictures will be grouped in albums, sorted by /$year/$arbitrary_name/<em>.jpg (eg 2019/foo/bar/album/</em>.jpg). On startup, it will pick up one album, randomly, and serve a few pictures from this album to anyone calling its /get_image web endpoint. Once it runs out of pictures for this album, it will select a new random album (with a new random subset of pictures).</p>
<p>The included client (which can be accessed on the root of the server) can be used to browser this picture (just point your browser to your wwwslide LAN address). It's not very smart, but it should work!</p>
<p>Remote control: each picture includes a QR code. Scanning the QR will take you to a local page with metadata of the shown image. This page can also be used to control wwwslide (eg to request that this album is displayed from the start, or to select a new album)</p>
<p>Reverse geolocation: the metadata of each picture includes a reverse-geolocation. No need to guess where you took a picture, wwwslide will guess for you (as long as your pictures have geotags in their exif data)</p>
</blockquote>
<p>wwwslide v0 was just a Flask service sending local-disk jpg's, and I found I frequently wondered where a particular picture was taken, or wish I had a way to see more pictures from a specific location. I'm quite proud of the idea to implement this: wwwslide will watermark pictures with a qr-code that can be used to get more info on the shown picture, and to display more picture of a specific album.</p>
<hr />
<h2><a href="/blog/2024/1012_rpixcompile.html">Crosscompiling to RaspberryPi Zero</a><a name="crosscompilingtoraspberrypizeroblog20241012_rpixcompile.html"></a></h2>
<p>Published 2024-10-12</p>
<p>Homeboard continues progressing, albeit at a snail pace. Using a RaspberryPi Zero as the base board means not only the project runs at a leisurely pace, but so do any attempts at compiling software in the target itself. Because I got tired of measuring my build times in minutes, I decided it's time to set up a cross-compiler from my PC to my homeboard. This means I can now build things in my reasonably fast PC, and deploy the resulting binary to the RaspberryPi Zero.</p>
<p>Setting up a cross compiler from scratch can be challenging, as it requires replicating a large chunk of your target. Luckily, the Raspberry Pi is a popular platform and plenty of articles explaining how to set up a x-compiler are available. Unluckily, I found most of them didn't work for me, with my host being Debian Bookworm. In the end I managed to find a combination of arcane spells to make x-compiling work.</p>
<p>First, get a Raspberry Pi Zero image, and mount it locally. This will be the sys-root of the target when x-compiling:</p>
<pre lang="bash"><code class="language-bash" lang="bash">wget https://downloads.raspberrypi.com/raspios_armhf/images/raspios_armhf-2024-07-04/2024-07-04-raspios-bookworm-armhf.img.xz
xz -d 2024-07-04-raspios-bookworm-armhf.img.xz
# Find out the mount-start offset (multiply by 512)
fdisk -lu "$IMG_FNAME" | grep Linux | awk '{print $2}'
mkdir -p mnt
mount -o loop,offset=541065216 2024-07-04-raspios-bookworm-armhf.img.xz ./mnt
</code></pre>
<p>And to build things:</p>
<pre><code>clang -target arm-linux-gnueabihf -mcpu=arm1176jzf-s --sysroot ./mnt/ test.c
</code></pre>
<p>That's all; this should create a binary in armv6 format, ready to be deployed to your target. A few things I discovered:</p>
<ul>
<li>I couldn't make this work with gcc. I don't know why.</li>
<li>If your <code>--sysroot</code> isn't correct, things won't work. You won't get an error, but a binary will still be built; it will just be a binary with the wrong format, and you'll only know because it will segfault on start. Good luck trying to figure out if the segfault is yours, or from a problem in the build process.</li>
</ul>
<p>I wrapped this in a convenient bash script so you can build a <a href="https://github.com/nicolasbrailo/rpiz-xcompile">makefile that will x-compile easily, have a look here: https://github.com/nicolasbrailo/rpiz-xcompile</a></p>
<hr />
<h2><a href="/blog/2024/1028_waylandonx.html">Homeboard: Wayland on X</a><a name="homeboardwaylandonxblog20241028_waylandonx.html"></a></h2>
<p>Published 2024-10-28</p>
<p>Besides <a href="/blog/2024/1012_rpixcompile.html">cross-compiling to RaspberryPi</a>, at times it's also useful to just run things locally. While faster than building on the target, the cycle of xcompile and deploy is still cumbersome for short sessions (i.e. when the target is usually offline, unpowered, and possibly lost somewhere in my house). For these situations, I found out I can run Wayland based apps on top of my X-based desktop, using Weston.</p>
<p>Weston is an implementation of Wayland. If you don't have it already, you can <code>apt-get install weston</code>. If you do this in an X based desktop, you can still run weston in a terminal, inside X.</p>
<p><a href="/blog_img/241028weston.jpg"><img alt="" src="/blog_img/241028weston.jpg" /></a></p>
<p>Between Wayland on X and <a href="/blog/2024/1012_rpixcompile.html">cross-compiling to RaspberryPi</a>, I can test my fork (hack) of <a href="https://github.com/nicolasbrailo/swayimg">Swayimg</a> for RaspberryPi Zero.</p>
<hr />
<h2><a href="/blog/2025/0209_HomeboardIndustrialDesign.html">Homeboard: Industrial Design (bonus: Inkscape)</a><a name="homeboardindustrialdesignbonusinkscapeblog20250209_homeboardindustrialdesign.html"></a></h2>
<p>Published 2025-02-09</p>
<p>My Homeboard project has officially left its cardboard pizza phase. Almost:</p>
<p><a href="/blog_img/0209_HomeboardIDv2.jpg"><img alt="" src="/blog_img/0209_HomeboardIDv2.jpg" /></a></p>
<p>The 2 or 3 pixels above show the first "industrial design" of the homeboard. Or at least the parts that "work". It's hanging from a wall, like a real picture frame. Unfortunately it has bugs, and all its guts are hanging from the top.</p>
<p>I spent some time working on a mount, cut with a laser engraver. The mount has two main pieces: a frame for the display, and a horizontal mount that can be hanged from a hook in the wall. The vertical display frame slots into the horizontal mount, meaning there is no flimsy glue holding expensive equipment: gravity does the job. There are some screws and Ls to give it a nice shape, but the main stress between the hook in the wall and the display is supported by the material strength, not by glue. All the cool electronics fit in a small box on top of the horizontal mount. Or at least that's the idea.</p>
<p>As nice as my design is, it has bugs: You can see in the picture I forgot to consider that wires, especially fat cables such as HDMIs, have physical properties, such as bend radius. Without a slot for wiring, the electronics that fit nicely on the top box in my drawing, actually protrude from the top. The ribbon cable was mirrored in my drawing, meaning a weird 180-degree twist was needed to fit the screen to the main board. The box itself doesn't lock, because the "teeth" are slightly misaligned. And the screw holes for the Raspberry Pi are about a quarter mm out of alignment.</p>
<p>Attached to this post is my SVG design, with theoretical bug-fixes for the problems (version 3, if anyone is counting). I haven't tried printing it yet, and I wouldn't be surprised if V4 is required too.</p>
<p><a href="/blog_img/0209_HomeboardV3.svg"><img alt="" src="/blog_img/0209_HomeboardV3.jpg" /></a></p>
<p>Image above shows the outline; clicking on it should open the original svg, which is probably mostly blank because vector laser cuts have 0.001mm strokes. Download and open with Inkscape to see it (you may need to change the view mode to outline, too).</p>
<h2>Bonus: misc Inkscape tips<a name="bonusmiscinkscapetips"></a></h2>
<p>My experience with anything that has colors is zero, and I had to spend time learning how Inkscape works to build the design above. Seeing a mechanical design you have in your head come to life with a laser cutter is incredibly rewarding, and I can see myself embarking in more ambitious designs some day, when I have more free time.  Here's a list of things I learned and should remember next time I'm using Inkscape:</p>
<ul>
<li>It's easy to build complex shapes from basic ones using Path &gt; Union/Difference/etc</li>
<li>millimeter alignment is hard by hand, but using the position and size input boxes it becomes easy. Start all sub-assemblies in a new drawing, at (0,0), and follow the plans to build the full assembly.</li>
<li>Actually, alignment by hand is easy (just not precise). It can be a time saver: Build guide-rules, then align by hand, finally adjust the position coordinates for precise fitting. For example, to place a screw hole in the bottom right corner, 3mm from the borders: the hard way is to calculate the position (width of board - 3mm - hole size / 2), same for height. The easy way: create a guide line at <code>width - 3mm</code> and <code>height - 3mm</code>. Place hole by hand, zooming in. The coordinates will usually be a few 100s or 10s of micrometers (um!) from the correct value, which you can then set by hand.</li>
<li>Actually, there's an even easier way: An element in inkscape will have 8 arrows around it. By default, the center of coordinates is the center of the object, but clicking on any of these arrows will make the coordinates relative to it. That means you can select the top center arrow of a screw hole, enter <code>board width - 3</code> to position it horizontally, then select the left center arrow and enter <code>board height - 3</code> to position it vertically.</li>
<li>When I write <code>board width - 3</code> I actually mean you can write <code>NNN - XXX</code> in the position boxes of Inkscape. They perform basic math operations. This is a huge time saver.</li>
<li>Most boards are regular, and have screw holes in symmetric positions vertically and horizontally. When this is the case, you can place all 4 screw holes by mirroring the first one: place the top left screw hole, then select it together with a box the size of the board. Mirror the board vertically, and place a new hole in the position of the first. Select both holes, mirror horizontally, etc. Voila, 4 screw holes with only one measurement!</li>
</ul>
<hr />
<h2><a href="/blog/2025/0216_HomeboardBootstrapV2.html">Homeboard V1, bootstrap V2</a><a name="homeboardv1bootstrapv2blog20250216_homeboardbootstrapv2.html"></a></h2>
<p>Published 2025-02-16</p>
<p>With ~most~ some of the <a href="/blog/2025/0209_HomeboardIndustrialDesign.html">bugs fixed in the industrial design</a>, it's time to setup a second Homeboard. That way I can experiment on one, while the other shows pretty pictures. Because my computer is also a new install, it's now a good opportunity to document the full bootstrap process from an almost brand new and clean Ubuntu 24.04.</p>
<h2>Bootstrap a new devenv<a name="bootstrapanewdevenv"></a></h2>
<ul>
<li>Get normal dev tools <code>sudo apt-get install build-essential git llvm vim</code></li>
<li>The linker needs to learn how to build arm binaries: <code>sudo apt-get install crossbuild-essential-armel crossbuild-essential-armhf</code></li>
<li>Clone the sw project: <code>git clone git@github.com:nicolasbrailo/homeboard.git</code></li>
<li>Don't forget to <code>git submodule update --init --recursive</code></li>
<li>Type <code>make xcompile-start</code> in the root of gpio_mon. It will, on its first run, setup the <a href="/blog/2024/1012_rpixcompile.html">cross-compile environment</a>.</li>
<li>The x-compile env will be "hardcoded" to some rpi image, for example <code>2024-11-19-raspios-bookworm-armhf.img.xz</code>. You probably want to update <code>~/src/homeboard/pi_gpio_mon/rpiz-xcompile/mount_rpy_root.sh</code> to make it point to a newer image, ideally the same one you will use to bootstrap the sd card.</li>
<li>Once <code>make xcompile-start</code> finishes, you can check it succeeded; <code>~/src/xcomp-rpiz-env/mnt</code> should contain a copy of the rpi environment (the x-compile root)</li>
</ul>
<h2>Bootstrap the OS<a name="bootstraptheos"></a></h2>
<p><a href="/blog/2024/0718_SonebakedMargheritaPictureFrame.html">This article</a> has been updated to work, but the gist of it is:</p>
<ul>
<li>Find the ISO you used for the x-compile env, then <code>sudo dd of=/dev/sdX if=./XXXX.img bs=8M status=progress</code></li>
<li>Mount the SD card and enable ssh: <code>cd /media/$USER/bootfs &amp;&amp; touch ssh &amp;&amp; touch ssh.txt</code></li>
<li><a href="https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-a-user">Create user (headless)</a>: <code>echo username:password &gt; /media/$USER/bootfs/userconf.txt</code></li>
<li>[Wayland] Add this magic to /boot/firmware/config.txt</li>
</ul>
<pre lang="bash"><code class="language-bash" lang="bash">dtoverlay=vc4-kms-v3d
gpu_mem=128
</code></pre>
<ul>
<li>[More Wayland] /boot/firmware/cmdline.txt needs to have <code>wayland=on</code></li>
<li>Boot up with the SD card, then ssh into the device and do <code>sudo apt-get install mesa-utils-bin wayfire seatd</code></li>
<li><a href="/blog/2024/0718_SonebakedMargheritaPictureFrame.html">Add Wayfire as a service</a></li>
</ul>
<h2>Build things<a name="buildthings"></a></h2>
<ul>
<li>Update the TARGET_IP in the makefile, then <code>make setup-ssh</code> to enable passwordless ssh</li>
<li>Start with the <code>gpio_mon</code> project, it's the simplest. <code>cd ~/src/homeboard/pi_gpio_mon</code>. If you <code>make</code>, it will either fail or create a binary in the wrong format if you haven't set up the <a href="/blog/2024/1012_rpixcompile.html">cross-compile environment</a> (see "bootstrap new devenv").</li>
<li>After <code>make</code> succeeds, <code>file gpiomon</code> should show something like <code>ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), dynamically linked</code>. This means your system can now build binaries for your target platform.</li>
<li><code>scp gpiomon $target</code> -&gt; try out if your xcompile env works as expected</li>
</ul>
<h2>Build harder things<a name="buildharderthings"></a></h2>
<ul>
<li>Move on to <code>wl_display_toggle</code> (it's the smallest project that exercises the entire stack: cross compiler and Wayfire).</li>
<li>There are more system deps you'll need to install; <code>make install_system_deps</code> should take care of most of them.</li>
<li>There are deps for the x-compile env too; <code>make install_sysroot_deps</code> should take care of most of them. Some deps may move around, and you may need to find newer versions.</li>
<li>Now <code>cd wl_display_toggle</code> then <code>make</code> and <code>scp wl_display_toggle $TARGET</code></li>
<li>ssh into the target, and try to shut off the display: <code>XDG_RUNTIME_DIR=/home/batman/run WAYLAND_DISPLAY="wayland-1" DISPLAY="" ./wl_display_toggle off</code></li>
</ul>
<h2>Install services<a name="installservices"></a></h2>
<p>The homboard doesn't do much nowadays, only show images; once you reached this point, and if things build and run, your build environment and target are ready to use. Just a few more arcane spells and we're done:</p>
<ul>
<li>Clean up binaries deployed ad-hoc, like gpio_mon and wl_display_toggle</li>
<li><code>make deploytgt</code></li>
<li>In the target, try out hackimg<ul>
<li>Run <code>XDG_RUNTIME_DIR=/home/batman/run WAYLAND_DISPLAY="wayland-1" DISPLAY="" /usr/lib/arm-linux-gnueabihf/ld-linux-armhf.so.3 /home/batman/homeboard/bin/hackimg /home/batman/homeboard/cfg/hackimg.cfg</code></li>
<li>You'll need to create the cache dir manually, because hackimg is lazy and won't do it for you</li>
</ul>
</li>
<li>Once you checked hackimg runs, <code>vi ~/homeboard/cfg/pipresencemon.cfg</code><ul>
<li>Set the sensor pin to the GPIO acting as presence sensor</li>
<li>Adapt the sensitivity to sensor type (mmwave vs PIR)</li>
<li>It's recommendable to use the mock gpio for a test run</li>
</ul>
</li>
<li>Try out the ambience service<ul>
<li></li>
</ul>
</li>
<li>In the target, <code>cd ~/homeboard/scripts &amp;&amp; ./install_svc.sh</code> - this will install the ambience service and launch it. Wayfire should already be a service by now, so no install is included.</li>
<li>Use <code>~/homeboard/scripts/logs.sh</code> to see what's broken.</li>
</ul>
<p>The target should be ready for production, in only about 30 simple steps!</p>
<h2>Appendix: it hangs!<a name="appendixithangs"></a></h2>
<p><a href="/blog_img/250216_Homeboard.jpg"><img alt="" src="/blog_img/250216_Homeboard.jpg" /></a></p>
<hr />
<p>Make sure the <code>meson</code> step finds curl and libjpeg, otherwise it won't be a very useful LAN picture frame.</p>
</div>

<div class="post_comments">

</div>

</div>

<div id="sitefooter">
   |
  <a href="/blog/history.html">Archive</a> |
  <a href="/blog/rss.xml">RSS</a>
</div>

<script src="/search.js"></script>
<script src="/codehighlight.js"></script>

</body>
</html>
