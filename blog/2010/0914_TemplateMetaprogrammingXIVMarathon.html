<h1>Blog title<a name="blogtitle"></a></h1>
<h1>Menu<a name="menu"></a></h1>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/blog/index.html">Blog</a></li>
<li><a href="/blog/history.html">History</a></li>
</ul>
<h1>Template Metaprogramming XIV: Marathon<a name="templatemetaprogrammingxivmarathon"></a></h1>
<p>If you remember previous entry, we got our evil device to the point of getting a specific instance using only a type hint. Now we need to put all the code together. I won't add much to the code, you should be able to parse it yourself.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">/<strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em>/
struct NIL {
    typedef NIL head;
    typedef NIL tail;
};
template &amp;lt;class H, class T=NIL&amp;gt; struct LST {
    typedef H head;
    typedef T tail;
};
/</strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>/
/</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong>/
template &amp;lt;class X, class Y&amp;gt; struct Eq { static const bool result = false; };
template &amp;lt;class X&amp;gt; struct Eq&amp;lt;X, X&amp;gt; { static const bool result = true; };
/</strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>/
/</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong>/
template &amp;lt;class Elm, class LST&amp;gt; struct Position {
private:
    typedef typename LST::head H;
    typedef typename LST::tail T;
    static const bool found = Eq&amp;lt;H, Elm&amp;gt;::result;
public:
    static const int result = found? 1 : 1 + Position&amp;lt;Elm, T&amp;gt;::result;
};
template &amp;lt;class Elm&amp;gt; struct Position&amp;lt;Elm, NIL&amp;gt; {
    static const int result = 0;
};
/</strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>/
/</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong>/
template &amp;lt;typename LST, int N&amp;gt; struct Nth {
    typedef typename LST::Tail Tail;
    typedef typename Nth&amp;lt;Tail, N-1&amp;gt;::result result;
};
template &amp;lt;typename LST&amp;gt; struct Nth&amp;lt;LST, 0&amp;gt; {
    typedef typename LST::head result;
};
/</strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>/
/</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong>/
template &amp;lt;typename Lst&amp;gt; struct Instances {
    typedef typename Lst::head Elm;
    Elm instance;
    Instances&amp;lt;typename Lst::tail&amp;gt; next;
};
template &amp;lt;&amp;gt; struct Instances&amp;lt;NIL&amp;gt; {};
/</strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>/
/</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong>/
template &amp;lt;int N, typename TypeLst&amp;gt; struct NthInstance {
    // This one isnt easy...
    // This is the next type in the list
    typedef typename TypeLst::tail TypeNext;
    //  * Nth::result is the Nth type in Lst (i.e. char, int, ...)
    typedef typename NthInstance&amp;lt;N-1, TypeNext&amp;gt;::NthInstanceType NthInstanceType;
    //  * typename Nth::result &amp;amp; is a reference to said type and the ret type
    template &amp;lt;typename InstancesLst&amp;gt;
    static NthInstanceType&amp;amp; get(InstancesLst &amp;amp;instances_lst) {
        return NthInstance&amp;lt;N-1, TypeNext&amp;gt;::get(instances_lst.next);
    }
};
// Remember, just for fun we choose a 1-based system (wtf..)
template &amp;lt;typename TypeLst&amp;gt; struct NthInstance&amp;lt;1, TypeLst&amp;gt; {
    typedef typename TypeLst::head NthInstanceType;
    template &amp;lt;typename InstancesLst&amp;gt;
    static NthInstanceType&amp;amp; get(InstancesLst &amp;amp;instances_lst) {
        return instances_lst.instance;
    }
};
/</strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>***/
class Facade {
    typedef LST&amp;lt;int, LST&amp;lt;char, LST&amp;lt;double&amp;gt; &amp;gt; &amp;gt; Lst;
    Instances&amp;lt;Lst&amp;gt; instances;
    public:
    template &amp;lt;typename PK&amp;gt; int find(PK) {
        return Position&amp;lt;PK, Lst&amp;gt;::result;
    }
    template &amp;lt;typename PK&amp;gt;
    // This is a difficult one... it should be parsed like this:
    //  1) Get the desired instance position using Position::result
    //  2) Get the type @ the desired position with NthInstance::Type
    //  3) Define said type as a return type (with an &amp;amp; at the end, i.e. make
    //      it a reference to the return type)
    typename NthInstance&amp;lt; Position&amp;lt;PK, Lst&amp;gt;::result, Lst &amp;gt;::NthInstanceType&amp;amp;
    get_instance(PK) {
        const int idx_position = Position&amp;lt;PK, Lst&amp;gt;::result;
        typedef typename NthInstance&amp;lt;idx_position, Lst&amp;gt;::NthInstanceType IdxType;
        IdxType &amp;amp;idx = NthInstance&amp;lt;idx_position, Lst&amp;gt;::get( instances );
        return idx;
    }
};
#include &amp;lt;iostream&amp;gt;
int main() {
    Facade f;
    int &amp;amp;a = f.get_instance(1);
    char &amp;amp;b = f.get_instance(&#x27;a&#x27;);
    double &amp;amp;c = f.get_instance(1.0);
    a = 42; b = &#x27;n&#x27;; c = 4.2;
    std::cout &amp;lt;&amp;lt; f.get_instance(1) &amp;lt;&amp;lt; &quot;\n&quot;;
    std::cout &amp;lt;&amp;lt; f.get_instance(&#x27;a&#x27;) &amp;lt;&amp;lt; &quot;\n&quot;;
    std::cout &amp;lt;&amp;lt; f.get_instance(1.0) &amp;lt;&amp;lt; &quot;\n&quot;;
    a = 43; b = &#x27;m&#x27;; c = 5.2;
    std::cout &amp;lt;&amp;lt; f.get_instance(1) &amp;lt;&amp;lt; &quot;\n&quot;;
    std::cout &amp;lt;&amp;lt; f.get_instance(&#x27;a&#x27;) &amp;lt;&amp;lt; &quot;\n&quot;;
    std::cout &amp;lt;&amp;lt; f.get_instance(1.0) &amp;lt;&amp;lt; &quot;\n&quot;;
    return 0;
}
</pre>
<p>The only thing missing now is a map, to convert a primitive type to an index type, but that's trivial and so it will be left as an exercise for the reader (?). We just implemented the most evil code in the whole world. Next time, the conclusions.</p>
<hr />
<p>Post by Nico Brailovsky @ 2010-09-14 -
    <a href="/blog/2010/0914_TemplateMetaprogrammingXIVMarathon.html">Permalink</a> -
    <a href="https://github.com/nicolasbrailo/nicolasbrailo.github.io/issues/new?title=Comment@/blog_md/2010/0914_TemplateMetaprogrammingXIVMarathon.md&amp;body=I%20have%20a%20comment!">Leave a comment</a></p>