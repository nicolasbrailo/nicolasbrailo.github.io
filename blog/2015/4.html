<h1>Blog title<a name="blogtitle"></a></h1>
<h1>Menu<a name="menu"></a></h1>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/blog/index.html">Blog</a></li>
<li><a href="/blog/history.html">History</a></li>
</ul>
<h1>Posts for 2015 April<a name="postsfor2015april"></a></h1>
<h1>Globing in bash<a name="globinginbash"></a></h1>
<p>By Nico Brailovsky @ 2015-04-30</p>
<p>There is a pretty common and unnecessary pattern used by bash scripts: whenever you need to loop through a list of file names in a path, you might tempted to write something like this.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">for fname in $(ls | grep foo); do echo $fname; done
</pre>
<p>You can save some typing by using bash-globbing:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">for fname in <em>foo</em>; do echo $fname; done
</pre>
<p>Not only the script should be cleaner and faster, bash will take care of properly expanding the file names and you won&rsquo;t have to worry about things like filenames with spaces. This should also be portable to other shells too.</p>
<p>Want to know more about bash globbibg? Check out http://www.linuxjournal.com/content/bash-extended-globbing</p>
<hr />
<h1>gdb: Print very long strings<a name="gdbprintverylongstrings"></a></h1>
<p>By Nico Brailovsky @ 2015-04-28</p>
<p>gdb defaults are usually quite sensible and just &ldquo;let you work&rdquo;. Some times, though, your project is not very sensible and you have to do weird things in gdb. An example: printing huge strings or vectors to try and reproduce a heisenbug. A lot of people get surprised at first because gdb will refuse to print very long strings, printing only the first few chars. Same for vectors. And if you have many repeating elements (eg &ldquo;f000000000000000000000000000000bar&rdquo;) you might see something like &ldquo;fooo0bar&rdquo;.
Just type these magic commands to see the whole string:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&gt; set print repeats 0
&gt; set print elements 0
</pre>
<hr />
<h1>gcc: Optimization levels and templates<a name="gccoptimizationlevelsandtemplates"></a></h1>
<p>By Nico Brailovsky @ 2015-04-21</p>
<p>Analyzing the assembly output for template devices can be a bit discouragging at times, specially when we spend hours trying to tune a mean looking template class only to find out the compiler is not able to reduce it&rsquo;s value like we expected. But hold on, before throwing all your templates away you might want to figure out why they are not optimized.</p>
<p>Let&rsquo;s start with a simple example: a template device to return the next power of 2:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &lt;int n, long curr_pow, bool stop&gt;
struct Impl_Next_POW2 {
    static const bool is_smaller = n &lt; curr_pow;
    static const long next_pow = _Next_POW2&lt;n, curr_pow*2, is_smaller&gt;::pow;
    static const long pow = is_smaller? curr_pow : next_pow;
};
template &lt;int n, long curr_pow&gt;
struct Impl_Next_POW2&lt;n, curr_pow, true&gt; {
    // This specializtion is important to stop the expansion
    static const long pow = curr_pow;
};
template &lt;int n&gt;
struct Next_POW2 {
    // Just a wrapper for _Next_POW2, to hide away some
    // implementation details
    static const long pow = _Next_POW2&lt;n, 1, false&gt;::pow;
};
</pre>
<p>Gcc can easily optimize that away, if you compile with &ldquo;g++ foo.cpp -c -S -o /dev/stdout&rdquo; you&rsquo;ll just see the whole thing is replaced by a compile time constant. Let&rsquo;s make gcc&rsquo;s life a bit more complicated now:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &lt;int n, long curr_pow, bool stop&gt;
struct Impl_Next_POW2 {
    static long get_pow() {
        static const bool is_smaller = n &lt; curr_pow;
        return is_smaller?
                    curr_pow :
                    _Next_POW2&lt;n, curr_pow*2, is_smaller&gt;::get_pow();
    }
};
template &lt;int n, long curr_pow&gt;
struct Impl_Next_POW2&lt;n, curr_pow, true&gt; {
    static long get_pow() {
        return curr_pow;
    }
};
template &lt;int n&gt;
struct Next_POW2 {
    static long get_pow() {
        return _Next_POW2&lt;n, 1, false&gt;::get_pow();
    }
};
</pre>
<p>Same code but instead of using plain static values we wrap everything in a method. Compile with &ldquo;g++ foo.cpp -c -S -fverbose-asm -o /dev/stdout | c++filt&rdquo; and you&rsquo;ll see something like this now:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">main:
    call    Next_POW2&lt;17&gt;::get_pow()
Next_POW2&lt;17&gt;::get_pow():
    call    _Next_POW2&lt;17, 1l, false&gt;::get_pow()
_Next_POW2&lt;17, 1l, false&gt;::get_pow():
    call    _Next_POW2&lt;17, 2l, false&gt;::get_pow()
_Next_POW2&lt;17, 2l, false&gt;::get_pow():
    call    _Next_POW2&lt;17, 4l, false&gt;::get_pow()
_Next_POW2&lt;17, 4l, false&gt;::get_pow():
    call    _Next_POW2&lt;17, 8l, false&gt;::get_pow()
_Next_POW2&lt;17, 8l, false&gt;::get_pow():
    call    _Next_POW2&lt;17, 16l, false&gt;::get_pow()
_Next_POW2&lt;17, 16l, false&gt;::get_pow():
    call    _Next_POW2&lt;17, 32l, false&gt;::get_pow()
_Next_POW2&lt;17, 32l, false&gt;::get_pow():
    movl    $32, %eax    #, D.2171
</pre>
<p>What went wrong? It&rsquo;s very clear for us the whole thing is just a chain of calls which could be replaced by the last one, however that information is now only available if you &ldquo;inspect&rdquo; the body of each function, and this is something the template instanciator (at least in gcc) can&rsquo;t do. Luckily you just need to enable optimizations, -O1 is enough, to have gcc output the reduced version again.</p>
<p>Keep it in mind for the next time you&rsquo;re optimizing your code with template metaprogramming: some times the template expander needs some help from the optimizer too.</p>
<h1>Comments<a name="comments"></a></h1>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/youfoundadeadlink.html">Griwes</a> commented @ 2015-04-22T10:44:15.000+02:00:<a name="inreplytothispostgriwesblog_mdyoufoundadeadlink.mdcommented20150422t104415.0000200"></a></h2>
<p>So&hellip; you don&rsquo;t like that GCC doesn&rsquo;t optimize when you don&rsquo;t pass optimization flags or what?</p>
<p>Original <a href="/blog/2015/0421_gccOptimizationlevelsandtemplates.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog_md">nicolasbrailo</a> commented @ 2015-04-22T10:52:45.000+02:00:<a name="inreplytothispostnicolasbrailoblog_mdcommented20150422t105245.0000200"></a></h2>
<p>While in hindsight it may be obvious that optimization and template instantiation are two different and orthogonal features, I&rsquo;ve seen many people assume that &ldquo;templates&rdquo; means &ldquo;optimal code&rdquo;. It&rsquo;s always good to understand how different features of a compiler interact.</p>
<p>Original <a href="/blog/2015/0421_gccOptimizationlevelsandtemplates.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="">Eric</a> commented @ 2015-04-22T14:21:43.000+02:00:<a name="inreplytothispostericcommented20150422t142143.0000200"></a></h2>
<p>You should stop using reserved identifiers.</p>
<p>Original <a href="/blog/2015/0421_gccOptimizationlevelsandtemplates.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog_md">nicolasbrailo</a> commented @ 2015-04-23T14:02:57.000+02:00:<a name="inreplytothispostnicolasbrailoblog_mdcommented20150423t140257.0000200"></a></h2>
<p>Indeed, good observation. I&rsquo;ll probably replace the underscores once I get some free time.</p>
<p>Original <a href="/blog/2015/0421_gccOptimizationlevelsandtemplates.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/youfoundadeadlink.html">robdesbois</a> commented @ 2015-05-07T10:13:44.000+02:00:<a name="inreplytothispostrobdesboisblog_mdyoufoundadeadlink.mdcommented20150507t101344.0000200"></a></h2>
<p>I&rsquo;m not sure this is the optimization level affecting template expansion at this point: collapsing the get_pow calls isn&rsquo;t an optimization specific to templates but general to any function calls.</p>
<p>It would be interesting to see if making the get_pow calls constexpr caused collapsing to take place even without optimization enabled.</p>
<p>Original <a href="/blog/2015/0421_gccOptimizationlevelsandtemplates.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog_md">nicolasbrailo</a> commented @ 2015-05-27T11:44:39.000+02:00:<a name="inreplytothispostnicolasbrailoblog_mdcommented20150527t114439.0000200"></a></h2>
<p>Indeed that&rsquo;s (more or less) the point of the article: templates != optimization. I haven&rsquo;t thought about playing around with constexpr&rsquo;s, I guess mostly because I&rsquo;m limited to 03 nowadays due to my job. I&rsquo;ll probably try it out some day.</p>
<p>Original <a href="/blog/2015/0421_gccOptimizationlevelsandtemplates.html">published here</a>.</p>
<hr />
<h1>Bash traps: almost like RAII for bash<a name="bashtrapsalmostlikeraiiforbash"></a></h1>
<p>By Nico Brailovsky @ 2015-04-16</p>
<p>Everywhere, but specially in bash, cleaning up is annoying and error prone. Resource leaks can be common if your bash script is interrupted half-way. Do you need to execute something always, even if your script fails or gets killed? Try using traps:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#!/bin/bash
foobar() {
    echo &quot;See ya!&quot;
}
trap &quot;foobar&quot; EXIT
</pre>
<p>It doesn&rsquo;t mater how you end this script, &ldquo;foobar&rdquo; will always be executed. Want to read more about bash traps? Check <a href="/blog/youfoundadeadlink.html">here.</a></p>
<hr />
<h1>C++: Invalidating references to elements in a vector<a name="cinvalidatingreferencestoelementsinavector"></a></h1>
<p>By Nico Brailovsky @ 2015-04-14</p>
<p>Is this valid C++?</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void do_something(const int&amp;amp;);
#include &lt;vector&gt;
void foo() {
    std::vector&lt;int&gt; v = {1,2,3,4,5};
    const int &amp;num = v.at(1);
    v.push_back(42);
    do_something(num);
}
</pre>
<p>Doesn&rsquo;t seem quite right, does it? push_back will most likely trigger a resize for the vector, and that will invalidate references to elements in the vector. num will end up pointing anywhere and so using it to call do_something is not valid C++. Or is it? What happens if we reserve some space for v?</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void do_something(const int&amp;amp;);
#include &lt;vector&gt;
void foo() {
    std::vector&lt;int&gt; v = {1,2,3,4,5};
    v.reserve(40);
    const int &amp;num = v.at(1);
    v.push_back(6);
    do_something(num);
}
</pre>
<p>It again might seem wrong, but this in fact is valid C++ code. Common sense might tell us that a call to push_back automatically invalidates references to elements in the vector, and it only works because most implementations will do the reasonable thing (ie not to invalidate references unless they must). Turns out the standard makes a special prevision for this case in section 23.3.6.5: a resize for a vector is guaranteed to be triggerd if, and only if, the capacity of the vector is not enough, and references to elements in the vector are guaranteed to be valid unless resize is triggered.</p>
<p>A bit of language laweyering shows that what seems like an error is in fact allowed by the standard, but even if this is valid C++ code you should always keep in mind that assuming that the capacity of a vector will be enough is a VERY big assumption, it&rsquo;s very easy to break and you won&rsquo;t get any warning when it happens (maybe a core dump, if you&rsquo;re lucky).</p>
<hr />
<h1>Code natural selection<a name="codenaturalselection"></a></h1>
<p>By Nico Brailovsky @ 2015-04-09</p>
<p>A funny thought just came to me: if you write nice clean code, it&rsquo;s easy to replace it. Just plug out an object somewhere, replace it with another one implementing the same interface, run the tests. Tada! On the other hand, if you write crappy code it might be nigh impossible to replace it. It will probably be worked around whenever a change is needed, simply adding layers of crust. Maybe that&rsquo;s why legacy code sucks: it&rsquo;s simply code natural selection - and the fittest to survive is simply the crappiest one. I think I&rsquo;m depressed now.</p>
<h1>Comments<a name="comments"></a></h1>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="">Adar</a> commented @ 2015-04-21T11:17:03.000+02:00:<a name="inreplytothispostadarcommented20150421t111703.0000200"></a></h2>
<p>You can look at it from the other side: nice code is more likely to be replicated and used in more projects.</p>
<p>Original <a href="/blog/2015/0409_Codenaturalselection.html">published here</a>.</p>
<hr />
<h1>Ruby-style digit separator for C-98?<a name="rubystyledigitseparatorforc98"></a></h1>
<p>By Nico Brailovsky @ 2015-04-07</p>
<p>A silly, and not very useful tip: I love how ruby allows you to write numbers like 1000000 as 1_000_000. Very useful to write benchmarking tests.</p>
<p>Until we get to C++14 we don&rsquo;t have a nice alternative, but we have an ugly hack we can use: instead of writing 1000000 write &ldquo;1 ## 000 ## 000&rdquo;.</p>
<p>It works, &lsquo;##&rsquo; is the preprocessor&rsquo;s token pasting operator, and it will paste two tokens together. Looks ugly, breaks the GUI highlighting, but at least you can count how many zeros you&rsquo;ve got.</p>
<p>Nitpicker&rsquo;s corner: multiplying by 10 is easier, but there is no job-safety involved in that.</p>
<p>Nitpicker&rsquo;s corner II: The evaluation order of a chain of &lsquo;##&rsquo; is not defined, but I don&rsquo;t expect this to cause any problems; any order of evaluation should result in the same result for this case.</p>
<hr />
<h1>Vim Tip: I want more menus!<a name="vimtipiwantmoremenus"></a></h1>
<p>By Nico Brailovsky @ 2015-04-02</p>
<p>As a uber vim geek, you shouldn&rsquo;t be using a lot of gui menus. Scratch that, you shouldn&rsquo;t be using any menus at all, period. Still, I&rsquo;ll admit it&rsquo;s a bit hard to remember every single shortcut for actions you rarely use.</p>
<p>Say, for example, you like to encrypt your text. Not always, but every once in a while. Enough to make a shortcut for it but not enough to remember what the shortcut is. You can try to grep your ~/.vimrc. You might find something like:</p>
<pre style="display: inline-block; border: 1px solid red;">&quot; Encrypt my stuff
map &lt;leader&gt;e ggg?G&lt;CR&gt;
</pre>
<p>(Yes, that command will actually encrypt your text in Vim. Try it!)</p>
<p>Wouldn&rsquo;t it be nice if you had a simpler way, though?</p>
<p>Turns out you can add your &ldquo;encrypt&rdquo; command to your gui. Then &ldquo;menu&rdquo; commands work just like the &ldquo;map&rdquo; family, but they create a GUI menu instead. Change your vimrc to something like this:</p>
<pre style="display: inline-block; border: 1px solid red;">&quot; Encrypt my stuff
map &lt;leader&gt;e ggg?G&lt;CR&gt;
menu Project.Encrypt ggg?G&lt;CR&gt;
</pre>
<p>Now if you reload your vimrc you&rsquo;ll find a new GUI menu created, from which you can easily encrypt your text. Decrypting is left as an exercise to the reader.</p>
<p>Extra tip: Want to try to learn the actual shortcut, like a real vim&rsquo;er? Then try this:</p>
<pre style="display: inline-block; border: 1px solid red;">menu Project.Encrypt&lt;TAB&gt;ggg?G ggg?G&lt;CR&gt;
</pre>
<p>Everything after the TAB will be right-aligned: you can use that space to annotate the key-combo you should use next time.</p>
<p>As usual, for more info check :help menu</p>
<h1>Comments<a name="comments"></a></h1>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/2016/1124_SimplevimpluginIintegratingnewcommands.html">Simple vim plugin I: integrating new commands | An infinite monkey - Nicolas Brailovsky&#39;s blog</a> commented @ 2016-11-24T08:00:30.000+01:00:<a name="inreplytothispostsimplevimpluginiintegratingnewcommandsaninfinitemonkeynicolasbrailovsky39sblogblog_md20161124_simplevimpluginiintegratingnewcommands.mdcommented20161124t080030.0000100"></a></h2>
<p>[&hellip;] tip: add these too if you want to have a GUI menu for your new commands as [&hellip;]</p>
<p>Original <a href="/blog/2015/0402_VimTipIwantmoremenus.html">published here</a>.</p>
<hr />