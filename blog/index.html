<h1>Blog title<a name="blogtitle"></a></h1>
<h1>Menu<a name="menu"></a></h1>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/blog/index.html">Blog</a></li>
<li><a href="/blog/history.html">History</a></li>
</ul>
<h1>Fix Spotify deeplinking in Linux + custom SpotiWeb UI<a name="fixspotifydeeplinkinginlinuxcustomspotiwebui"></a></h1>
<p>By Nico Brailovsky @ 2023-12-16</p>
<p>After a recent update I found <a href="https://nicolasbrailo.github.io/SpotiWeb/">my custom Spotify UI (*)</a> wasn&rsquo;t working. The way my custom UI works is by generating a simple list of followed artists, and then playing in the native app by using deep-linking. A recent update seems to have broken this in Linux based OSes, so here&rsquo;s my fix:</p>
<pre lang="bash" style="display: inline-block; border: 1px solid red;">sudo mv /usr/share/spotify/spotify /usr/share/spotify/spotify.real
sudo echo &#x27;/usr/share/spotify/spotify.real &ndash;uri=&quot;$1&quot;&#x27; &gt; /usr/share/spotify/spotify
</pre>
<p>Seems old versions of spotify would try to open anything as a deeplink, but new versions require a <code>--uri</code> parameter on argv. Surely there is a cleaner way of doing this in xdg-open, but I&rsquo;m too lazy to read manuals.</p>
<p>In the &ldquo;reminder to myself&rdquo; category, as there is zero chance I&rsquo;ll remember this next time I&rsquo;m setting up a computer.</p>
<h3>(*) SpotiWeb: custom Spotify UI<a name="spotiwebcustomspotifyui"></a></h3>
<p>I don&rsquo;t like&rdquo;recent&rdquo; changes (recent being the last 3 or 4 years!) to Spotify&rsquo;s UI, <a href="https://nicolasbrailo.github.io/SpotiWeb/">so I rolled out my own</a>. It&rsquo;s a plain, boring, unobtrusive view of all your followed artists, grouped by categories. It also runs in any browser and is extremely minimalist (doesn&rsquo;t even have a search function: you can use the browser&rsquo;s search if you need one!)</p>
<p>The app is hosted in github pages, and because it&rsquo;s entirely client side it doesn&rsquo;t need any kind of server side support to run. Check out the source here and <a href="https://github.com/nicolasbrailo/SpotiWeb">either run your own, or check out there&rsquo;s no server side processing involved.</a></p>
<hr />
<h1>Translated to Chinese!<a name="translatedtochinese"></a></h1>
<p>By Nico Brailovsky @ 2023-01-14</p>
<p>&ldquo;Small celebratory post, because I never expected it:</p>
<p>&ldquo;</p>
<p><a href="/blog_img/212446793-30c64252-a788-4a6d-81e2-e8f05f126497.jpg"><img alt="" src="/blog_img/212446793-30c64252-a788-4a6d-81e2-e8f05f126497.jpg" /></a>
Someone translated <a href="http://github.com/nicolasbrailo/pianOli">one of my open source projects</a> to Chinese!</p>
<hr />
<h1>Bash script preamble<a name="bashscriptpreamble"></a></h1>
<p>By Nico Brailovsky @ 2021-06-27</p>
<p>All background Bash scripts should start with this preamble:</p>
<blockquote>
<p>set -euo pipefail
exec &gt; ~/log.log 2&gt;&amp;1
</p>
</blockquote>
<p>There are countless articles explaining why, and the main purpose of this one is a reminder for myself, so I won&rsquo;t go into the details. For reference:</p>
<ul>
<li><strong>-e</strong> halts the script on error</li>
<li><strong>-u</strong> errors when using an undefined variable</li>
<li><strong>-o pipefail</strong> makes pipe error return value sane</li>
<li><strong>exec &gt; ~/log.log 2&gt;&amp;1</strong> redirect all output to ~/log.log</li>
</ul>
<hr />
<h1>Where is the fun in that?<a name="whereisthefuninthat"></a></h1>
<p>By Nico Brailovsky @ 2021-03-18</p>
<p>You can always find coders asking why coding isn&rsquo;t fun anymore. I can somewhat relate but I never understood why the answer isn&rsquo;t obvious: coding isn&rsquo;t software engineering. When you go from coding to engineering, the focus changes. A lot of the interesting stuff is there, but there&rsquo;s also not-interesting-stuff in the mix. Maybe testing and documenting isn&rsquo;t your thing, you just want to build something. Maybe the stability from testing and documenting isn&rsquo;t that important to you. Perhaps you know you&rsquo;re the only one who&rsquo;s ever going to read your code. Your future self may be angry at you for a little while if the code breaks&hellip; so what? Your experiment crashed? Just reboot it. No problem.</p>
<p>If you&rsquo;re coding-to-sell, you&rsquo;re not writing code for yourself. You write for a team, even if that team is only you and future-you. You write it so it may scale and adapt to new requirements. You write it to survive a bit more than a weekend, and to be stable. You&rsquo;re not writing code to learn new things, that&rsquo;s only a nice side-effect; you are trying to build a product.</p>
<p>Furthermore, you&rsquo;re not investing time to learn something or just to have fun; you&rsquo;re trading time for money (if you learn something in the process, that&rsquo;s good - but probably not why you&rsquo;re being paid a salary as a software engineer).</p>
<p>It&rsquo;s understandable that parts of software engineering are not as fun as it was hacking in a basement while you were a kid. There is still a very big overlap, but it&rsquo;s not just the same activity. Myself, I try to focus on the fun parts and just have discipline to get the boring parts out of the way. I usually work in places where the balance is fairly decent, and it&rsquo;s kept me interested in software development for the last 15 (ish) years. I&rsquo;m hoping it&rsquo;ll do the trick for much longer than that.</p>
<hr />
<h1>reboot succesful?<a name="rebootsuccesful"></a></h1>
<p>By Nico Brailovsky @ 2021-03-17</p>
<p>&ldquo;Since &ldquo;migrating&rdquo; from Wordpress to Blogspot:</p>
<ul>
<li>Traffic to Wordpress fell from ~100ish visitors a day to ~30 or ~40ish.</li>
<li>This site went from 0 to also ~30 or ~40ish.</li>
</ul>
<p>That went much better than I expected, considering I couldn&rsquo;t set up a proper HTTP301-permanently moved (WP charges you for that, which IMO is slight extortionate for a site I don&rsquo;t want to monetize). Let&rsquo;s see how it goes 10 years from now, when I have to migrate from Blogpost to something else.</p>
<hr />
<h1>sudo reboot<a name="sudoreboot"></a></h1>
<p>By Nico Brailovsky @ 2021-03-02</p>
<p>Recently found out Wordpress had pretty aggressive ads on my blog. That worked as the encouragement I was needing to work on a task I&rsquo;d been putting off for years: fix bit-rotted content! I took the opportunity to fix all (most) broken links and source code snippets from the last 14 years. It was supposed to be a short sed script, which of course ended up being 3 days of work - a lot of it manual. A few cool things I figured doing this:</p>
<ul>
<li>Even if I very sparingly add new posts, 14 years is still a lot of content. By the infinite monkey theorem, some of it should be good. Right?</li>
<li>A new reason to dislike template metaprogramming: so many &lsquo;template &lt; class &gt;&lsquo;, so much broken code&hellip;</li>
<li>I have 400+ posts and less than 10 images. While I quite like adding visual content, very little of it (except memes!) survived the successive blog migrations.</li>
<li>I can estimate there have been at least 3 platform migrations since the first post. I can count the number of times that &lsquo;&lt;&rsquo; gets html-encoded like the rings of a tree. &lsquo;&amp;amp;lt;&rsquo; was the longest encode sequence I found.</li>
</ul>
<p>&ldquo;</p>
<hr />
<h1>Writing Vim plugins<a name="writingvimplugins"></a></h1>
<p>By Nico Brailovsky @ 2021-03-02</p>
<h2>Vim utilities: Findgrep &amp; Fastgrep<a name="vimutilitiesfindgrepfastgrep"></a></h2>
<p>I spent some time writing utility scripts for my Vim setup. I figured I can share them here, someone may even find them useful or at least get a laugh out of it. Last time I presented &ldquo;Impl switcher&rdquo;, and &ldquo;Better Tab New&rdquo; before that. Today it&rsquo;s Findgrep &amp; Fastgrep&rsquo;s turn.</p>
<p>I <a href="/blog/2012/1030_Fastgrepacacheforgrep.html">wrote about Fastgrep a long time ago</a>. The idea behind it is to speed up the slowest part in a grep command, the disk seek time, by creating a huge blob file with all the files in a project concatenated.</p>
<p>Fastgrep works great. But it requires a context switch, going from your IDE to your console just to grep. Findgrep fills the gap between the IDE and the command line: this utility provides a few key bindings to let you quickly run some common commands, like searching for a selected string or finding a file in the project directory.</p>
<p>You can get <a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/fastgrep.sh">Fastgrep here</a>. <a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/vim/plugins/findgrep.vim">Findgrep is available in Github</a>, and you can easily replace Fastgrep with normal grep if you need to.</p>
<hr />
<h2>Vim utilities: Impl switcher<a name="vimutilitiesimplswitcher"></a></h2>
<p>I spent some time writing utility scripts for my Vim setup. I figured I can share them here, someone may even find them useful or at least get a laugh out of it. Last time I presented &ldquo;<a href="/blog/2016/0701_VimutilitiesBetterTabNew.html">BTN: Better Tab New</a>&rdquo;. Today it&rsquo;s the turn for &ldquo;Impl switcher&rdquo;.</p>
<p>With its very imaginative name, &ldquo;Impl switcher&rdquo; has a very obvious purpose: it will just switch from a header file to an implementation file. So, between .h and .cpp. Surely there are lots of Vim plugins to do just that, why write another one?</p>
<p>Most impl-switcher plugins in the wild tend to, in my experience, require either a lot of configuration, a lot of dependencies, or a very specific project layout (or a combination of all three). They also seem to be huge and very complicated projects.</p>
<p>Impl switcher will recursively go up your directory hierarchy and use &ldquo;find&rdquo; to locate any files named like your base file but with a different extension. That makes it very simple and it requires minimal (if any) configuration: just drop it in your .vimrc file and you&rsquo;re good to go. OK, not exactly: it requires a Linux-like system with utilities like &ldquo;find&rdquo;. Still, a good trade-off to keep the project&rsquo;s dependencies as small as possible.</p>
<p>Get &ldquo;impl swicher&rdquo; here:</p>
<ul>
<li><a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/vim/plugins/impl_switcher.vim">Git hub repo</a></li>
<li><a href="http://www.vim.org/scripts/script.php?script_id=5406">Impl switcher&rsquo;s Vim page</a></li>
</ul>
<hr />
<h2>Vim utilities: Better Tab New<a name="vimutilitiesbettertabnew"></a></h2>
<p>I spent some time writing utility scripts for my Vim setup. I figured I can share them here, someone may even find them useful or at least get a laugh out of it. The first one is called &ldquo;Better Tab New&rdquo; and you can get it from my <a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/vim/plugins/bettertabnew.vim">Github repo</a> or from the script&rsquo;s <a href="http://www.vim.org/scripts/script.php?script_id=5405">Vim page</a>.</p>
<p>Why would you want a better tab new, and what&rsquo;s wrong with the default one? Simple: tabnew, in Vim, will just open a file. For that to happen you need to specify the exact path of a file. That&rsquo;s usually perfectly fine, but sometimes you need tabnew to be a bit smarter: maybe you just grep&rsquo;ed something and ended up with a path that looks like &ldquo;/foo/bar/baz:my_text:42&rdquo;. Or maybe you want to open a file and go to a specific line. Those are things for which the default tabnew implementation isn&rsquo;t very good. BTN fills that niche and lets you create a simpler workflow when using grep.</p>
<p>Get BTN: Better Tab New here:</p>
<ul>
<li><a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/vim/plugins/bettertabnew.vim">Gihub repo</a></li>
<li><a href="http://www.vim.org/scripts/script.php?script_id=5405">BTN&rsquo;s Vim page</a></li>
</ul>
<hr />
<h2>Simple vim plugin I: integrating new commands<a name="simplevimpluginiintegratingnewcommands"></a></h2>
<p>TL;DR: <a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/vim/plugins/findgrep.vim">Here&rsquo;s some code</a> to integrate system commands into vim. You can just drop it in your vimrc, create a small wrapper function in your vimrc and configure a few key binding to make it work.</p>
<p>Longer version:
We can extend our quick grep integration to other commands, quite easily. Since we defined a few wrappers to request input, get it from visual mode or just guess it, we can also have a helper function to create a scratch buffer and read a system command into it:</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">&quot; Find&amp;amp;Grep command wrapper: execute cmd, shows the results in a scratch buffer
function! FG_EvalSysCmdInNewBuff(cmd)
    tabnew
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
    execute &#x27;$read !&#x27; . a:cmd
    setlocal nomodifiable
endfunction
&quot; Wrap a normal action: ask the user for input, then call func with it
function! FG_RequestInputAction(msg, func)
    let needle = input(a:msg)
    if strlen(needle) &amp;gt; 0
        execute &#x27;call&#x27; a:func .&#x27;(&quot;&#x27;. needle . &#x27;&quot;)&#x27;
    endif
endfunction
&quot; Wrap a visual action: call func with whatever is selected under the cursor
function! FG_VAction(func)
    &quot; Copy whatever is selected in visual mode
    try
        silent! let a_save = @a
        silent! normal! gv&quot;ay
        silent! let needle = @a
    finally
        silent! let @a = a_save
    endtry
    &quot; Remove whitespaces
    let needle = substitute(needle, &quot;\n\+&quot;,&quot;&quot;,&quot;g&quot;)
    let needle = substitute(needle, &quot;\r\+&quot;,&quot;&quot;,&quot;g&quot;)
    let needle = substitute(needle, &quot;^\s\+\|\s\+$&quot;,&quot;&quot;,&quot;g&quot;)
    if strlen(needle) &amp;gt; 0
        execute &#x27;call&#x27; a:func .&#x27;(&quot;&#x27;. needle . &#x27;&quot;)&#x27;
    endif
endfunction
&quot; Wrap a normal action: call func with whatever is under the cursor
function! FG_NAction(func)
    let needle = expand(&quot;&amp;lt;cword&amp;gt;&quot;)
    if strlen(needle) &amp;gt; 0
        execute &#x27;call&#x27; a:func .&#x27;(&quot;&#x27;. needle . &#x27;&quot;)&#x27;
    endif
endfunction
</pre>
<p>Integrating any new command into our plugin is now trivial. Let&rsquo;s do it for grep and for find:</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">&quot; Wrap a find command: search for file &quot;needle&quot;, show results in a new window
function! FG_DoFindFile(needle)
    let cmd = &#x27;find -type f -iname &quot;<em>&#x27; . a:needle . &#x27;</em>&quot;&#x27;
    call FG_EvalSysCmdInNewBuff(cmd)
endfunction
&quot; Wrap a grep command: search for needle, show results in a new window
function! FG_DoSearchText(needle)
    let cmd = &#x27;grep -nri &quot;&#x27; . a:needle . &#x27;&quot; *&#x27;
    call FG_EvalSysCmdInNewBuff(cmd)
endfunction
</pre>
<p>Then just add a few key bindings and you&rsquo;re good to go:</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">gt;f :call FG_NAction(&quot;FG_DoFindFile&quot;)&amp;lt;CR&amp;gt;
vmap &amp;lt;leader&amp;gt;f :call FG_VAction(&quot;FG_DoFindFile&quot;)&amp;lt;CR&amp;gt;
map  &amp;lt;leader&amp;gt;S :call FG_RequestInputAction(&quot;Text search: &quot;, &quot;FG_DoSearchText&quot;)&amp;lt;CR&amp;gt;
nmap &amp;lt;leader&amp;gt;s :call FG_NAction(&quot;FG_DoSearchText&quot;)&amp;lt;CR&amp;gt;
vmap &amp;lt;leader&amp;gt;s :call FG_VAction(&quot;FG_DoSearchText&quot;)&amp;lt;CR&amp;gt;
map  &amp;lt;leader&amp;gt;F :call FG_RequestInputAction(&quot;Find file: &quot;, &quot;FG_DoFindFile&quot;)&amp;lt;CR&amp;gt;
</pre>
<p>This is an actual plugin I use in my Vim setup. You can grab the <a href="https://github.com/nicolasbrailo/Nico.rc/blob/master/vim/plugins/findgrep.vim">latest version from my Github repo.</a></p>
<p>Extra tip: add these too if you want to have a <a href="/blog/2015/0402_VimTipIwantmoremenus.html">GUI menu</a> for your new commands as well.</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">menu Project.Find\ File :call FG_RequestInputAction(&quot;FG_DoFindFile&quot;)
menu Project.Text\ Search :call FG_RequestInputAction(&quot;FG_DoSearchText&quot;)
</pre>
<hr />
<h2>Simple vim plugin II: a psychic project greper<a name="simplevimpluginiiapsychicprojectgreper"></a></h2>
<p>We have been working on a quick grep integration for Vim, and it&rsquo;s looking decent enough for a quick plugin. There&rsquo;s one more easy thing we can improve, though: let&rsquo;s make it psychic! So far we had to tell grep what to look for, either by selecting the text in visual mode or by actually typing the search terms. Typing! That&rsquo;s so old fashioned. Let&rsquo;s make grep guess what to look for.</p>
<p>In vim you have a psychic function, expand(&ldquo;&rdquo;). If you call expand(&ldquo;&rdquo;), it will return whatever word is under the cursor. No need to visually select it. If you&rsquo;re still using the same vimrc definitions, you can do something like</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">nmap s :call FG_DoSearch(expand(&quot;&quot;))
</pre>
<p>Let&rsquo;s clean things up a little bit:</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">&quot; Wrap a grep command: search for needle, show results in a new window
function! FG_DoSearch(needle)
    let grepbin = &#x27;grep -nri &#x27;
    tabnew
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
    let cmd = grepbin . &#x27; &quot;&#x27; . a:needle . &#x27;&quot; *&#x27;
    echom cmd
    execute &#x27;$read !&#x27; . cmd
    setlocal nomodifiable
endfunction
&quot; Wrap a normal action: ask the user for input, then call func with it
function! FG_RequestInputAction(msg, func)
    let needle = input(a:msg)
    if strlen(needle) &gt; 0
        execute &#x27;call&#x27; a:func .&#x27;(&quot;&#x27;. needle . &#x27;&quot;)&#x27;
    endif
endfunction
&quot; Wrap a visual action: call func with whatever is selected under the cursor
function! FG_VAction(func)
    &quot; Copy whatever is selected in visual mode
    try
        silent! let a_save = @a
        silent! normal! gv&quot;ay
        silent! let needle = @a
    finally
        silent! let @a = a_save
    endtry
    &quot; Remove whitespaces
    let needle = substitute(needle, &quot;\n\+&quot;,&quot;&quot;,&quot;g&quot;)
    let needle = substitute(needle, &quot;\r\+&quot;,&quot;&quot;,&quot;g&quot;)
    let needle = substitute(needle, &quot;^\s\+\|\s\+$&quot;,&quot;&quot;,&quot;g&quot;)
    if strlen(needle) &gt; 0
        execute &#x27;call&#x27; a:func .&#x27;(&quot;&#x27;. needle . &#x27;&quot;)&#x27;
    endif
endfunction
&quot; Wrap a normal action: call func with whatever is under the cursor
function! FG_NAction(func)
    let needle = expand(&quot;&lt;cword&gt;&quot;)
    if strlen(needle) &gt; 0
        execute &#x27;call&#x27; a:func .&#x27;(&quot;&#x27;. needle . &#x27;&quot;)&#x27;
    endif
endfunction
nmap &lt;leader&gt;s :call FG_NAction(&quot;FG_DoSearchText&quot;)&lt;CR&gt;
vmap &lt;leader&gt;s :call FG_VAction(&quot;FG_DoSearchText&quot;)&lt;CR&gt;
map  &lt;leader&gt;S :call FG_RequestInputAction(&quot;Text search: &quot;, &quot;FG_DoSearchText&quot;)&lt;CR&gt;
</pre>
<p>Just copy paste that in your vimrc, now you can grep your project in three different ways: press s (,s) to look for the word currently under the cursor, S to type in a search term or select something in visual mode, then S to grep it.</p>
<hr />
<h2>Simple vim plugin III: a polymorphic project greper<a name="simplevimpluginiiiapolymorphicprojectgreper"></a></h2>
<p>We&rsquo;ve recently seen a very basic function to integrate grep to vim. We can improve it a little bit with very simple changes. Using this tip to have <a href="/blog/2015/0602_Vimtippolymorphickeybindings.html">different key binding for different modes</a> we can do something a bit smarter . Let&rsquo;s create two functions, one for normal mode that should prompt the user what to search for, and another function to automagically pick whatever is selected:</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">function! FG_DoSearch(needle)
    let grepbin = &#x27;grep -nri &#x27;
    tabnew
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
    let cmd = grepbin . &#x27; &quot;&#x27; . a:needle . &#x27;&quot; *&#x27;
    execute &#x27;$read !&#x27; . cmd
    setlocal nomodifiable
endfunction
function! FG_Search()
    let needle = input(&quot;Search for: &quot;)
    call FG_DoSearch(needle)
endfunction
function! FG_Visual_Search()
    &quot; Copy whatever is selected in visual mode
    try
        silent! let a_save = @a
        silent! normal! gv&quot;ay
        silent! let needle = @a
    finally
        silent! let @a = a_save
    endtry
    call FG_DoSearch(needle)
endfunction
nmap &lt;leader&gt;s :call FG_Search()&lt;CR&gt;
vmap &lt;leader&gt;s :call FG_Visual_Search()&lt;CR&gt;
</pre>
<p>The magic here happens in the mapping: nmap will create a mapping that&rsquo;s only enabled when on &ldquo;normal&rdquo; mode, vmap when you&rsquo;re in visual mode. As usual, check :help map for more details.</p>
<hr />
<h2>Simple vim plugin IV: project greping<a name="simplevimpluginivprojectgreping"></a></h2>
<p>I recently wrote about some of the utilities I created for my Vim setup. Using someone else&rsquo;s Vim scripts is not nearly as fun as writing your own, so I decided to also write a short summary on what it takes to get started writting Vim plugins. For this task, I decided to start with greping.</p>
<p>Greping can be improved a bit: if you do it a lot in a project, you might find it&rsquo;s useful to also grep the results themselves, to further refine your search. If you have your grep results in vim itself, that is trivial.</p>
<p>Let&rsquo;s start hacking something in our .vimrc file. Try this:</p>
<pre lang="ruby" style="display: inline-block; border: 1px solid red;">function! FG_Search()
    let needle = input(&quot;Search for: &quot;)
    tabnew
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
    let grepbin = &#x27;grep -nri &#x27;
    let cmd = grepbin . &#x27; &quot;&#x27; . needle . &#x27;&quot; *&#x27;
    execute &#x27;$read !&#x27; . cmd
    setlocal nomodifiable
endfunction
map &lt;leader&gt;s :call FG_Search()&lt;CR&gt;
</pre>
<p>This function should be pretty clear: it will map <leader>s (in my case, &ldquo;,s&rdquo;) to FG_Search(). FG_Search will prompt the user for a term to grep, then search for it executing the command. In the end the results are written to a new tab, which is declared as a temp non-modifiable buffer.</p>
<p>Just paste that in your .vimrc and you&rsquo;re good to grep.</p>
<p><strong>Extra tip</strong>: integrate this with my fast grep cache and you have a nice and quick project search integration for vim that works even for very large projects with tools available in most default Linux installs.</p>
<hr />
<h1>Vectorization in gcc<a name="vectorizationingcc"></a></h1>
<p>By Nico Brailovsky @ 2021-03-02</p>
<p>[WARNING: DRAFT VERSION, WORK IN PROGRESS]</p>
<p>Intro</p>
<p>What is vectorization? That much shouldn&rsquo;t be difficult to answer: whenever you perform the same operation to all elements of a vector you can either do it one by one, or in chunks. You could do it by splitting the chunks across different processors. You can also tell your processor to process a whole chunk at once (extra points if you noticed that these are orthogonal aspects, you could split your vector in chunks, send it to multiple processors and then tell each processor to work on a chunk of that chunk). If you opt to process by chunks on a single processor, you will then use a special set of instructions (SIMD, single instruction multiple data) that can work on several elements at the same time.</p>
<p>It doesn&rsquo;t seem like a conceptually hard topic to discuss, but looks can be deceptive. Let&rsquo;s toy around with gcc&rsquo;s vectorization capabilities and see what we can learn by telling gcc to vectorize this simple snipet:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
#define SIZE (5)
long sum(int v[SIZE]) throw()
{
    long s = 0;
    for (unsigned i=0; i&amp;lt;SIZE; i++) s += v[i];
    return s;
}
</pre>
<p>As usual, the empty throw is in there so we can get a cleaner assembly output. To compile this I&rsquo;m using &ldquo;g++ -S -c foo.cpp -o /dev/stdout | c++filt&rdquo;.</p>
<p>If you run that you will notice there isn&rsquo;t anything vectorized. Good, because vectorization is an optimization, and we didn&rsquo;t tell gcc we wanted to optimize our program. Vectorization is turned on by default on -O3, but that also triggers a bunch of other optimizations we don&rsquo;t want right now. Instead we can use &ldquo;-O2 -ftree-vectorize&rdquo;. Just as a sanity check, you could compile with -O0 and -O2; for such a simple snippet there shouldn&rsquo;t be any major differences which could make the assembly harder to understand.</p>
<p>Adding the new flags needed to tell gcc to vectorize:</p>
<pre lang="bash" style="display: inline-block; border: 1px solid red;">
g++ -O2 -ftree-vectorize -S -c foo.cpp -o /dev/stdout | c++filt
</pre>
<p>Did you run that? Quite disappointing, isn&rsquo;t it? Nothing was vectorized. Why? Let&rsquo;s ask gcc: there&rsquo;s an option called &ldquo;-ftree-vectorizer-verbose&rdquo;. Let&rsquo;s set it to 7 and see what gcc can tell us about the vectorization pass:</p>
<pre lang="bash" style="display: inline-block; border: 1px solid red;">
&amp;gt; g++ -O2 -ftree-vectorize -ftree-vectorizer-verbose=7 -S -c foo.cpp -o /dev/stdout | c++filt
vec.cpp:7: note: Alignment of access forced using peeling.
(&hellip; A bunch of stuff we don&#x27;t care about right now &hellip;)
  Calculated minimum iters for profitability: 11
vec.cpp:7: note:   Profitability threshold = 10
vec.cpp:7: note: not vectorized: vectorization not profitable.
vec.cpp:3: note: vectorized 0 loops in function.
</pre>
<p>That&rsquo;s interesting information: we&rsquo;ll talk about peeling later on, that&rsquo;s important but not right now. What is critical right now is the last message we got for line 7: &ldquo;vectorization not profitable&rdquo;.</p>
<p>Using SSE is not free, some special registers in the CPU need to be enabled and then some housekeeping needs to be done to keep them working, so they are not available unless you actually request them. If you will &ldquo;invest&rdquo; time into setting SSE up, you want to make sure it eventually pays off. And in this case, for a meager 10-iterations loop, it doesn&rsquo;t.</p>
<p>To enable vectorization you could increase the number of iterations. GCC also has an option called min-vect-loop-bound, you could probably fiddle around with this to force the vectorization of our example but it&rsquo;s probably not worth it.</p>
<hr />
<p>Peeking at a vectorized function</p>
<p>If we just compile and check the assembly for the snippet we used before, we&rsquo;ll have a frankenstein full of assembly. Let&rsquo;s slightly alter our snipet with a few magic words for now (we&rsquo;ll see what they mean later on) to get a cleaner assembly, and then we&rsquo;ll start inspecting that.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
#define SIZE (100)
struct Foo { int v[100]; } <strong>attribute</strong> ((aligned (<strong>BIGGEST_ALIGNMENT</strong>)));
long sum(Foo <strong>restrict</strong> * v) throw()
{
    long s = 0;
    for (unsigned i=0; i&amp;lt;SIZE; i++) s += v-&amp;gt;v[i];
    return s;
}
</pre>
<p>Unimportant note: __restrict__ is not actually needed here, but until we discuss what that keyword does you should be using it, it will (in most cases) make your assembly much cleaner.</p>
<p>If you compile this with &ldquo;g++ -O2 -ftree-vectorize -ftree-vectorizer-verbose=7 -S -c&rdquo; you&rsquo;ll now see a big difference in the analysis gcc gives us:</p>
<pre style="display: inline-block; border: 1px solid red;">
(&hellip;)
vec.cpp:8: note: Cost model analysis:
  Vector inside of loop cost: 5
  Vector outside of loop cost: 4
  Scalar iteration cost: 3
  Scalar outside cost: 0
  prologue iterations: 0
  epilogue iterations: 0
  Calculated minimum iters for profitability: 3
vec.cpp:8: note:   Profitability threshold = 3
vec.cpp:8: note: LOOP VECTORIZED.
vec.cpp:5: note: vectorized 1 loops in function.
</pre>
<p>Whatever those magic incantations mean, they seem to improve the vectorization process: now the profitability threshold is much lower. You can probably imagine why already, but since we&rsquo;ll cover that later on for now let&rsquo;s just keep it in the TODO list. For now, just check out the assembly you get. Shouldn&rsquo;t be to hard to interpret once you know that xmm* are the simd registers, just like R*X registers but for vector operations. The code itself is quite straightforward, it&rsquo;s the usual algorithm you&rsquo;d have written in assembly but using special vector operations (all those punpck*dq ops).</p>
<hr />
<p>C&rsquo;s abstract machine</p>
<p>Remember all those weird things we had to tell the compiler to get gcc to properly vectorize our code? Well, turns out vector operations have a catch: they don&rsquo;t play nicely with unaligned data and aliasing pointers (what does that mean? be patient!).</p>
<p>In a way, C and C++ describe a &ldquo;virtual machine&rdquo; that kind of resembles an old single thread mono-processor architecture, and the compiler needs to map instructions in this simple architecture to a much more complex design, a modern architecture full of multi level caches, multiple processors, multiple threads per processor and complex instruction sets like SIMD. To do that, it needs to analyze the code to guarantee certain constrains are met.</p>
<p>An example of how the C virtual machine constraints a program: signed integers aren&rsquo;t supposed to overflow, if they do then that&rsquo;s a (programmer) error and the compiler is free to assume it will never happen. Unsigned integers, on the other hand, are free to overflow as much as needed, they just wrap around. Keeping this in mind and for code like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
template &amp;lt;typename T&amp;gt;
bool foo(T x) {
    return (x &amp;gt; x+1);
}
</pre>
<p>It looks really simple, but there&rsquo;s a catch. From a math perspective, foo should always return true. From a C virtual machine perspective, foo should always return true iif x+1 can&rsquo;t overflow. Just try and see what happens if you compile the above code for T=unsigned int and for T=int. A C virtual machine can assume that a signed integer will never overflow (because the standard says so) and thus will just produce code similar to &ldquo;return true&rdquo;, at least for -O2. Unsigned ints, on the other hand, may wrap around to 0 so the compiler can&rsquo;t assume this: try it out and you&rsquo;ll see that even with optimizations on, there will be some kind of check performed.</p>
<p>Where are we going with this long explanation? Aligned data and aliasing pointers, that&rsquo;s where. Now that you know how C can apply optimizations according to what it can &ldquo;prove&rdquo; for the code being analyzed we&rsquo;ll see next time what we need to prove about our code to make it vectorizable.</p>
<hr />
<p>Vectorization constraints: Aliasing pointers</p>
<p>Knowing a little bit more how our C &ldquo;virtual machine&rdquo; restricts what we can say about our program, let&rsquo;s talk about pointer aliasing with this example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
#define SIZE (100)
void test(int v1[SIZE], int v2[SIZE])
{
    for (unsigned i=0; i&amp;lt;SIZE; i++) v1[i] = 2*v2[i];
}
</pre>
<p>If you compile that with something like &ldquo;g++ -O2 -ftree-vectorize -ftree-vectorizer-verbose=7 -S -c vec.cpp&rdquo; you&rsquo;ll probably get the following out of the vectorizer:</p>
<pre style="display: inline-block; border: 1px solid red;">
vec.cpp:15: note: versioning for alias required: can&#x27;t determine dependence between <em>D.2078_11 and </em>D.2077_7
vec.cpp:15: note: mark for run-time aliasing test between <em>D.2078_11 and </em>D.2077_7
(&hellip; A lot more of output we don&#x27;t care about right now &hellip;)
</pre>
<p>That&rsquo;s a funny little message. And if you now check the assembly output, you&rsquo;ll see it&rsquo;s much more complex than what you could have expected. What&rsquo;s going on?</p>
<p>Let&rsquo;s start by figuring out what &ldquo;dependence between *D.2078_11 and *D.2077_7&rdquo; means. Where do those strange names come from? If you spend some time digging through gcc assembly, you&rsquo;ll soon notice that those are the kind of names gcc&rsquo;s backend uses to referr to variables. In fact, you can compile with &ldquo;-fverbose-asm&rdquo; and a comment will be placed for each variable access: D.2078 and D.2077 refer to the two input parameters that test receives. And gcc is telling us that it can&rsquo;t determine whether there is a dependency between them or not, so it got marked for &ldquo;run-time aliasing test&rdquo;.</p>
<p>Pointer aliasing is what happens if two pointers may overlap. For example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
int sum(int <em>x, int  </em>y) {
    for (unsigned i=0; i&amp;lt;3; ++i) {
        int n = x[i];
        x[i] = n + y[i];
    }
}
</pre>
<p>That looks like a simple function. Until we call it like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
int main() {
    int x[] = {1, 2, 3, 4, 5, 6};
    int <em>x1 = &amp;amp;x[1];
    int </em>x3 = &amp;amp;x[3];
    sim(x1, x3);
    return 0;
}
</pre>
<p>Here it&rsquo;s quite clear that for &ldquo;sum&rdquo;, x and y might overlap. If the elements are processed one by one (like C&rsquo;s abstract machine says it should be done) all is quite clear and we don&rsquo;t care too much whether the elements overlap or not, their result will always be the same and will always be defined. If, however this changes and we intend to vectorize this function, a problem arises: if we process by chunks, instead of processing by elements, the behavior of sum would suddenly change!</p>
<p>The vectorizer must ensure no behavior changes are introduced, so one of the steps needed to vectorize a function is to ensure there&rsquo;s no overlap between pointers (or, to use the proper terms, no pointer aliasing), and C99 has a keyword to tell the compiler &ldquo;these two pointers will never alias&rdquo; called restrict. Unfortunately there&rsquo;s no such keyword for C++, so a compiler extension will have to be used instead:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
#define SIZE (100)
void test(int * <strong>restrict</strong> v1, int * <strong>restrict</strong> v2)
{
    for (unsigned i=0; i&amp;lt;SIZE; i++) v1[i] = 2*v2[i];
}
</pre>
<p>Doing this takes care of the messages saying that the compiler can&rsquo;t prove there&rsquo;s no dependency between the two parameters to our test function. Don&rsquo;t waste too much time trying to analyze the assembly right now, though. You&rsquo;ll probably see this message somewhere on the vectorizer&rsquo;s output: &ldquo;Vectorizing an unaligned access&rdquo;. This means more problems for our test program, but we&rsquo;ll leave that for later.</p>
<hr />
<p>Pointer aliasing in C++</p>
<p>TODO // C99 vs C++11 / valarray</p>
<hr />
<p>Runtime checking of pointer aliasing</p>
<hr />
<p>Vectorizing unaligned accesses</p>
<p>Remember our example?</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
#define SIZE (100)
void test(int * <strong>restrict</strong> v1, int * <strong>restrict</strong> v2)
{
    for (unsigned i=0; i&amp;lt;SIZE; i++) v1[i] = 2*v2[i];
}
</pre>
<p>Compiling that should probably give you a message like this one:</p>
<pre style="display: inline-block; border: 1px solid red;">
vec.cpp:9: note: vect_model_load_cost: unaligned supported by hardware.
(&hellip;)
vec.cpp:9: note: Alignment of access forced using peeling.
vec.cpp:9: note: Vectorizing an unaligned access.
(&hellip;)
</pre>
<p>What does that mean? Remember our long explanation about how the abstract machine C defines constraints on the program analysis, and how that meant the compiler couldn&rsquo;t be sure that two pointers won&rsquo;t alias? Turns out vectorization also has a problem with unaligned accesses too. If your list of ints starts somewhere accross alignment accesses, SSE will have problems. Luckily that&rsquo;s not a deal breaker for gcc: it detected our architecture supports &ldquo;unaligned accesses&rdquo; so it does something called &ldquo;peeling&rdquo; to align the access.</p>
<p>Peeling means that because the access is not guaranteed to be aligned, gcc will implement a short loop to &ldquo;peel&rdquo; a few iterations out of the main loop, so the main loop&rsquo;s accesses can be aligned. How? Imagine your vector of ints starts at 0xF123 and you need 0x10 alignment; gcc will create a short loop that will iterate, element by element, 12 times, until 0xF130. Then the main loop can start from 0xF130 and all its accesses will be aligned.</p>
<p>You may have also noticed a message like this:</p>
<pre style="display: inline-block; border: 1px solid red;">
vec.cpp:9: note: cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown .
</pre>
<p>Like you can imagine, there&rsquo;s a prologue peel loop (the one we&rsquo;ve already discussed) and an epilogue peel loop; since we&rsquo;re processing by chunks of N elements per loop, then our iteration must end at some multiple of N. This means we might have up to N-1 elements that can&rsquo;t be processed by the main loop; these get taken care of by the epilogue peel loop. Of course you might choose to take a simpler path and wrap your vector like this:</p>
<pre style="display: inline-block; border: 1px solid red;">
struct Foo { int v[100]; } <strong>attribute</strong> ((aligned (<strong>BIGGEST_ALIGNMENT</strong>)));
</pre>
<p>// TODO: add alignas example</p>
<hr />
<p>Using intrinsics</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
#define SIZE (100)
struct Foo { int v[100]; } <strong>attribute</strong> ((aligned (<strong>BIGGEST_ALIGNMENT</strong>)));
long sum(Foo <strong>restrict</strong> * v) throw()
{
    long s = 0;
    for (unsigned i=0; i&amp;lt;SIZE; i++) s += v-&amp;gt;v[i];
    return s;
}
</pre>
<p>// TODO
https://software.intel.com/sites/landingpage/IntrinsicsGuide/
http://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html
http://stackoverflow.com/questions/7156908/sse-intrinsic-functions-reference</p>
<hr />
<p>Some closing thoughts</p>
<p>Vectorization is not easy, specially if you care about portability. Luckily the compiler does an amazing job on handling the complexity and freeing you of all the nitty-gritty problems around vectorizing a function. You don&rsquo;t really need to check if you&rsquo;r pointers alias or not, or whether your reads are properly aligned: you just need to write your loop and let the compiler do its magic, it will evaluate if it&rsquo;s worth optimizing or not, and if it is it will take care of creating helper code to make vectorization work properly.</p>
<p>The downside to all the black-box magic the compiler does on loop-vectorization is quite big, though: you loose all visibility into how your code actually works. It might work wonderfully one day and then the next it might become the slowest part of your program, because a small change made gcc miss the chance of vectorization.</p>
<p>If (or when) gcc looses the ability to vectorize one of your loops, you&rsquo;ll be digging around a lot of compiler logs to try and figure out what went wrong. If you were to write the vectorized loop yourself using intrinsics you&rsquo;d be certain that the loop works and it&rsquo;s vectorized (duh!) but you&rsquo;d have to manage the portability, alignment and aliasing yourself. That&rsquo;s not a trivial task if you are aiming for a portable program.</p>
<p>If you plan to write a portable vectorized program, your best bet is to check your compiler&rsquo;s manual to see exactly which vectorization types are supported (that means, which types of plain looks can be transformed into vectorized loops). For a full list of all transformations available in gcc, check http://gcc.gnu.org/projects/tree-ssa/vectorization.html#using.</p>
<hr />
<h1>Understanding the C preprocessor<a name="understandingthecpreprocessor"></a></h1>
<p>By Nico Brailovsky @ 2021-03-02</p>
<hr />
<h2>C preprocessor: Just a simple replacer?<a name="cpreprocessorjustasimplereplacer"></a></h2>
<p>Lately, out of curiosity, I spent some time to better understand how the C preprocessor works. I admit it, I thought it was a very dumb copy-paste based replace mechanism, only capable of doing the simpler keyword matching and replacement. Boy, was I wrong. Turns out the preprocessor is actually an organically grown pseudo language (as opposed to a properly designed language feature) inside C, which later got standardized through an incredibly complex set of rules and definitions. Rules for recursion, expansion, pattern matching and crazy operators like # and ## are some of the things that I never before knew existed in the preprocessor.</p>
<p>During my time toying with the preprocessor I learned a few things about recursion, the different operators supported by it and some crazy things about the order of conditional evaluation. I&rsquo;ll summarize some of the things I learned in the next few posts: you might want to check 16.3 in the C++ standard, since the next few articles will be only explanations about different paragraphs on this section.
Disclaimer: if you find any real-world utility to these bits of preprocessor trivia, you are probably doing something horribly wrong or horribly evil!</p>
<hr />
<h2>C preprocessor II: stringify operator<a name="cpreprocessoriistringifyoperator"></a></h2>
<p>We all more or less know the list of operators that C++ provides for &ldquo;normal code&rdquo; but not everyone is aware that the preprocessor also has special operators we can use. Small difference: an operator like &lsquo;+&rsquo; will usually operate on numbers, but the preprocessor operates only on a single concept: source code tokens. What kind of operators could a preprocessor have, then? Two, actually. Let&rsquo;s start with the simpler one:</p>
<p><strong>Stringify</strong>
The &lsquo;#&rsquo; operator is the simplest operator of the preprocessor: it converts the next token to string. Something like this, for example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define f(x) to_str(x) == #x
f(123)
</pre>
<p>Would print</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">to_str(123) == &quot;123&quot;
</pre>
<p>A restriction applies to the stringify operator: it can only be applied to a macro param, not just any token. So this, for example, is an illegal macro:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define f(x) #123 == #x
</pre>
<p>There&rsquo;s another operator, which is a bit more &ldquo;esoteric&rdquo;. We&rsquo;ll talk about token pasting next time.</p>
<hr />
<h2>C preprocessor III: Token pasting<a name="cpreprocessoriiitokenpasting"></a></h2>
<p>A stringify operator is good but the token pasting operator goes off the awesomeness chart (if you&rsquo;re working on an ioccc entry, that is). Actually, what token pasting does is conceptually simple: it will paste together two tokens to form a new one. So, for example, PASTE(foo, bar) would result in the &ldquo;foobar&rdquo; token. Looks simple enough, doesn&rsquo;t it? The token pasting operator is invoked via &lsquo;##&rsquo;. For example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define PASTE(x, y) x ## y
#define FOOBAR 42
int main() { return PASTE(FOO, BAR); }
</pre>
<p>The previous code would just return 42. So what&rsquo;s the usefulness of a paste operator? Other than obfuscating stuff, you can use it to create classes with similar interfaces but different method names (I&rsquo;m not saying it&rsquo;s a good idea, I&rsquo;m saying you can). For example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define MAKE_GET_SET(x, T) \
               void set_ ## x (T o) { this-&amp;gt;x = o; } \
               T get_ ## x () { return this-&amp;gt;x; }
class Foo {
  MAKE_GET_SET(foo, int);
</pre>
<p>The token pasting operator doesn&rsquo;t have the limitation of being applicable only to a macro parameter, so code like &ldquo;12 ## 34&rdquo; is a perfectly valid operation which results in &ldquo;1234&rdquo;. It does have a catch: if the resulting token is not valid the behavior is undefined. This means that, for example, pasting &ldquo;12&rdquo; and &ldquo;foo&rdquo; together produces &ldquo;12foo&rdquo;, which is not a valid token. Being the operation undefined means that a compiler might reject this operation (I&rsquo;m pretty sure gcc does) or that it might do a completely different thing (it could choose to ignore the token pasting operator and it would still be standard compliant).</p>
<p>Nasal demons FTW!</p>
<hr />
<h2>C preprocessor IV: VA Args<a name="cpreprocessorivvaargs"></a></h2>
<p>And things just got even more awesome in our preprocessor series: if just passing a known number of parameters is not cool enough for you you can use a variable number of arguments on a macro definition too. This is very useful to implement printf style debug macros which get replaced by no tokens on a release build. Or to make debugging a bit more complicated, your choice.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define DEBUG(fmt, &hellip;) printf(fmt, <strong>VA_ARGS</strong>);
</pre>
<p>Combining this with stringify will provide you hours of fun. Combining this with token pasting&hellip; well, that&rsquo;s just evil.</p>
<hr />
<h2>C preprocessor V: Conditionals<a name="cpreprocessorvconditionals"></a></h2>
<p>While walking around the c preprocessor we came to know the stringify operator, the crazy token pasting operator and a __VA_ARGS__ macro. All very weird, but at least the #if&rsquo;s work in a sane way&hellip; or do they? They do, but there&rsquo;s some room for unexpected behavior if you don&rsquo;t know some implementation details. Take this code for example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#if 0
#  if 0
#  else
#  elif true
#  endif
#endif
</pre>
<p>Clearly the inner if is wrong because the else clause comes before the elseif, however you might think it doesn&rsquo;t matter because it&rsquo;s surrounded by an #if 0. Surprise: it does matter, that&rsquo;s not valid preprocessor input. Even if the outer #if is not &ldquo;taken&rdquo;, whatever preprocessing directives are inside it should still be valid (though anything that&rsquo;s not a preprocessing directive will indeed be ignored).</p>
<p>Even though at first it might seem weird for things inside an #if 0 to be important, it makes sense if you think that should an internal #if not respect the proper structure then the preprocessor wouldn&rsquo;t know when to end the first #if 0. Then again, if you find any real-world utility to this bit of preprocessor implementation trivia, you are doing something horribly wrong!</p>
<hr />
<h2>C preprocessor VI: Recursive macro expansion rules<a name="cpreprocessorvirecursivemacroexpansionrules"></a></h2>
<p>What happens if you define a recursive macro? This might seem like a silly question, but by asking it we can gain some insight on the inner working of the preprocessor.</p>
<p>Let&rsquo;s start with a simple example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define foo bar 1
#define bar foo 2
foo
</pre>
<p>Luckily the preprocessor is smart enough not to trip up on this simple piece of code. When expanding foo on line three it will do something like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define foo bar
#define bar foo
foo
// Applies foo -&amp;gt; bar 1
bar 1
// Applies bar -&amp;gt; foo 2
foo 2 1
// Scans foo again&hellip; but doesn&#x27;t expand it
</pre>
<p>The second time the preprocessor scans foo it won&rsquo;t expand it: it &ldquo;knows&rdquo; foo was already expanded, so it won&rsquo;t do it again. But how does it know that foo was already expanded? Let&rsquo;s try something a bit more complicated:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define foo bar a baz b
#define bar foo 1
#define baz bar 2
foo
</pre>
<p>And then let&rsquo;s see how foo is expanded, step by step:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define foo foo a bar b baz c
#define bar foo 1
#define baz bar 2
foo
</pre>
<p>First the rule &ldquo;foo -&gt; foo a bar b baz c&rdquo; will be applied and the results rescanned: let&rsquo;s call this scope 1. We&rsquo;ll end up with:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">foo a bar b baz c
</pre>
<p>Now the results of this expansion will be scanned, in a new scope. Let&rsquo;s call it scope 2. The first token the preporcessor will see is &ldquo;foo&rdquo;, which was already expanded on scope 1: it will be ignored and it will continue to the next expandable token, &ldquo;bar&rdquo;, and it will expand it like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">foo a foo 1 b bar 2 c
</pre>
<p>On the scope that baz&rsquo;s expansion creates (scope 4), the parent&rsquo;s scope expansion rules are &ldquo;inherited&rdquo;, so for scope 4 &ldquo;foo&rdquo; was already expanded but &ldquo;bar&rdquo; was not, because bar&rsquo;s expansion happened on scope 3 and scope 3 is not scope&rsquo;s 4 parent. Not following me? Try following this diagram:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">foo -&amp;gt; foo a bar b baz c
    foo -&amp;gt; already expanded, ignore
    a   -&amp;gt; not a macro, ignore
    bar -&amp;gt; expand to &quot;foo 1&quot;
        foo -&amp;gt; expanded at parent scope, ignore
        1   -&amp;gt; not a macro, ignore
    b   -&amp;gt; not a macro, ignore
    baz -&amp;gt; expand to &quot;bar 2&quot;
        bar -&amp;gt; expand to &quot;foo 1&quot;
            foo -&amp;gt; already expanded at parent scope, ignore
            1   -&amp;gt; not a macro, ignore
        2   -&amp;gt; not a macro, ignore
    c   -&amp;gt; not a macro, ignore
</pre>
<p>Hopefully the preprocessor expansion rules should be a bit more clear now: each expansion creates a scope, each scope inherits from parent&rsquo;s scopes whether a rule was applied or not and if it was then said rule is ignored in the current scope.</p>
<p>Of course these rules get more complicated when dealing with token pasting and stringifying operators, because each phase (stringifying, token pasting, rescanning and expansion) will happen in a specific order. Things get even more complicated when you realize (by reading the standard) that said order is not the same when you deal with argument replacement.</p>
<p>Then again, it&rsquo;s probably a good idea if your macros don&rsquo;t rely on the recursive expansion rules of the preprocessor.</p>
<hr />
<h2>C preprocessor VII: Recursive expansion on function macros<a name="cpreprocessorviirecursiveexpansiononfunctionmacros"></a></h2>
<p>The last time we talked about recursive expansion rules on C&rsquo;s preprocessor: to sum it up, each expansion creates a scope, that contains a list of all macros which have already been expanded in said scope, or in a parent scope. That gives us a very nice and easy to understand tree of already-expanded rules.</p>
<p>Clearly that&rsquo;s too easy for C. We need more complexity: we need to make the expansion rules interact with the argument substitution process and the preprocessor operators too!</p>
<p>How exactly? The whole process is specified by a very tiny paragraph, 16.3.1, on the standard, which despite being tiny contains a lot of information. Actually, it contains all the expansion and precedence rules for the preprocessor. And it&rsquo;s more or less like this:</p>
<ol>
<li>Argument scanning: the perprocessor binds a set of tokens to each argument name. If there are extra arguments and the token &ldquo;&hellip;&rdquo; is part of the macro&rsquo;s signature, a __VA_ARGS__ argument is created. (to put it simply: it will bind a set of tokens like &ldquo;(a,b)&rdquo; to an identifier like &ldquo;ARG1&rdquo;).</li>
<li>Stringify and token pasting is applied ONLY to the arguments, not to the body function.</li>
<li>Each argument is recursively scanned for macro expansion, as if each argument was on a file on its own (imagine a new file is created with only preprocessor directives and the argument, then apply the expansion algorithm recursively to that file).</li>
<li>After the arguments have been fully expanded, they are substituted on the macro&rsquo;s body.</li>
<li>The resulting definition is then rescanned for macro expansions or token pasting operators.</li>
<li>A side effect of this multi-phase macro expansion is that the nice expansion tree we used to have no longer works.</li>
</ol>
<p>Let&rsquo;s take this example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#define str(&hellip;) #<strong>VA_ARGS</strong>
#define foo(a, b) foo a bar str(b)
#define bar foo bar 1
foo(bar, (1, 2, 3))
</pre>
<p>How can we expand this macro call? Like this:</p>
<pre style="display: inline-block; border: 1px solid red;">expand{ foo(bar) }
        Match foo with definition of macro: foo(a)
            Bind a to bar
            Macro expand argument a -&gt; expand{ bar }
                    bar takes no arguments, no binding is done
                    Apply rule bar -&gt; foo bar 1
                    Scan the result for new expanions
                            foo was already expanded, no further expansion
            Bind b to (1, 2, 3)
            Macro expand argument b -&gt; nothing to expand
        Replace macro expanded arguments in body definition:
            -&gt; foo foo bar 1 bar str((1, 2, 3))
        Rescan the body for further expansion:
                foo: Already expanded on current scope
                foo: Already expanded on current scope
                bar: Already expanded (The compiler will have too keep a map of expanded macros for each identifier in a definition!)
                bar: Needs expansion
                        Apply rule bar -&gt; foo bar 1
                        Rescan for further expansion
                                foo: Already expanded on parent scope
                                bar: Already expanded on current scope
                str((1, 2, 3)): Expand macro call
                        Bind (1, 2, 3) to <strong>VA_ARGS</strong>
                            Analyze (1, 2, 3) for further expansion
                            Apply operator &#x27;#&#x27; to (1, 2, 3) -&gt; &quot;(1, 2, 3)&quot;
                        Replace #<strong>VA_ARGS</strong>
                Replace the result of str((1,2,3)) -&gt; &quot;(1, 2, 3)&quot;
        Replace the original call &quot;foo(bar, (1, 2, 3))&quot; for the result
            -&gt; foo foo bar 1 foo bar 1 &quot;(1, 2, 3)&quot;
</pre>
<p>This last example should be a good representative of the complexities involved in a macro expansion; hopefully now you know more than you ever wanted to know about macros.</p>
<hr />
<h1>C++ exceptions under the hood<a name="cexceptionsunderthehood"></a></h1>
<p>By Nico Brailovsky @ 2021-03-02</p>
<h3>Index<a name="index"></a></h3>
<ol>
<li><a href="#chapter_n_2">A tiny ABI</a></li>
<li><a href="#chapter_n_3">An ABI to appease the linker</a></li>
<li><a href="#chapter_n_4">Catching what you throw</a></li>
<li><a href="#chapter_n_5">Magic around __cxa_begin_catch and __cxa_end_catch</a></li>
<li><a href="#chapter_n_6">Gcc_except_table and the personality function</a></li>
<li><a href="#chapter_n_7">A nice personality</a></li>
<li><a href="#chapter_n_8">Two-phase handling</a></li>
<li><a href="#chapter_n_9">Catching our first exception</a></li>
<li><a href="#chapter_n_10">_Unwind_ and call frame info</a></li>
<li><a href="#chapter_n_11">Reading a CFI table</a></li>
<li><a href="#chapter_n_12">And suddenly, reflexion in C++</a></li>
<li><a href="#chapter_n_13">Setting the context for a landing pad</a></li>
<li><a href="#chapter_n_14">Multiple landing pads &amp; the teachings of the guru</a></li>
<li><a href="#chapter_n_15">Finding the right landing pad</a></li>
<li><a href="#chapter_n_16">Finding the right catch in a landing pad</a></li>
<li><a href="#chapter_n_17">Reflecting on an exception type and reading .gcc_except_table</a></li>
<li><a href="#chapter_n_18">Getting the right stack frame</a></li>
<li><a href="#chapter_n_19">Getting the right catch in a landing pad</a></li>
<li><a href="#chapter_n_20">Running destructors while unwinding</a></li>
<li><a href="#chapter_n_21">A summary and some final thoughts</a></li>
<li><a href="#chapter_n_I">The true cost of an exception</a></li>
<li><a href="#chapter_n_II">Metaclasses and RTTI on C++</a></li>
</ol>
<p>Everyone knows that good exception handling is hard. Reasons for this abound, in every single layer of an exception &ldquo;lifetime&rdquo;: it&rsquo;s hard to write exception safe code, an exception might be thrown from unexpected places (pun intended!), it&rsquo;s can be complicated to understand badly designed exception hierarchies, it&rsquo;s slow because a lot of voodoo is happening under the hood, it&rsquo;s dangerous because improperly throwing an exception might call the unforgiving std::terminate. And although anyone who might have had to battle an &ldquo;exceptional&rdquo; program might know this, the reasons for this mess are not widespread knowledge.</p>
<p>The first question we need to ask ourselves is then, how does it all work. This is the first article on a long series, in which I&rsquo;ll be writing about how exceptions are implemented under the hood in c++ (actually, c++ compiled with gcc on x86 platforms but this might apply to other platforms too). On these articles the process of throwing and catching an exception will be explained with quite a lot of detail, but for the impatient people here is a small brief of all the articles that will follow: how is an exception thrown in gcc/x86:
1. When we write a throw statement, the compiler will translate it into a pair of calls into libstdc++ functions that allocate the exception and then start the stack unwinding process by calling libstdc.
2. For each catch statement, the compiler will write some special information after the method&rsquo;s body, a table of exceptions this method can catch and a cleanup table (more on the cleanup table later).
3. As the unwinder goes through the stack it will call a special function provided by libstdc++ (called personality routine) that checks for each function in the stack which exceptions can be caught.
4. If no matching catch is found for the exception, std::terminate is called.
5. If a matching catch is found, the unwinder now starts again on the top of the stack.
6. As the unwinder goes through the stack a second time it will ask the personality routine to perform a cleanup for this method.
7. The personality routine will check the cleanup table on the current method. If there are any cleanup actions to be run, it will &ldquo;jump&rdquo; into the current stack frame and run the cleanup code. This will run the destructor for each object allocated at the current scope.
8. Once the unwinder reaches the frame in the stack that can handle the exception it will jump into the proper catch statement.
9. Upon finishing the execution of the catch statement, a cleanup function will be called to release the memory held for the exception.</p>
<p>This already looks quite complicated and we haven&rsquo;t even started; that was but a short and inaccurate description of all the complexities needed to handle an exception.</p>
<p>To learn about all the details that happen under the hood on the next article we will start to implement our own mini libstdlibc++. Not all of it though, only the part that handles exceptions. Actually not even all of that, only the bare minimum we need to make a simple throw/catch statement work. Some assembly will be needed, but nothing too fancy. A lot of patience will be required, I&rsquo;m afraid.</p>
<p>If you are too curious and want to start reading about exception handling implementation then you can start <a href="/blog/youfoundadeadlink.html">here</a>, for a full specification of what we are going to implement on the next few articles. I&rsquo;ll try to make these articles a bit more didactic and easier to follow though, so see you next time to start our ABI!</p>
<h6>** Disclaimer note: I&rsquo;m in no way versed on the magic going on when an exception is thrown. These series will be about trying to demystify the stuff going on under the hood and learning something in the process, and while I hope some of it will be correct I have no doubts there will be a lot of subtleties not quite right. Let me know if you think I should correct something **</h6>
<hr />
<h2>C++ exceptions under the hood 2: a tiny ABI<a name="cexceptionsunderthehood2atinyabi"></a></h2>
<p>If we are going to try and understand why exceptions are complex and how do they work, we can either read a lot of manuals or we can try to write something to handle the exceptions ourselves. Actually, I was surprised by the lack of good information on this topic: pretty much everything I found is either incredibly detailed or very basic, with one exception or two. Of course there are some specifications to implement (most notably the <a href="/blog/youfoundadeadlink.html">ABI for c++</a> but we also have <a href="http://www.logix.cz/michal/devel/gas-cfi/">CFI</a>, <a href="http://www.logix.cz/michal/devel/gas-cfi/dwarf-2.0.0.pdf">DWARF</a> and libstdc) but reading the specification alone is not enough to really learn what&rsquo;s going on under the hood.</p>
<p>Let&rsquo;s start with the obvious then: wheel reinvention! We know for a fact that plain C doesn&rsquo;t handle exceptions, so let&rsquo;s try to link a throwing C++ program with a plain C linker and see what happens. I came up with something simple like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &quot;throw.h&quot;
extern &quot;C&quot; {
    void seppuku() {
        throw Exception();
    }
}
</pre>
<p>Don&rsquo;t forget the extern stuff, otherwise g++ will helpfully mangle our little function&rsquo;s name and we won&rsquo;t be able to link it with our plain C program. Of course, we need a header file to &ldquo;link&rdquo; (no pun intended) the C++ world with the C world:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct Exception {};
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
    void seppuku();
#ifdef __cplusplus
}
#endif
</pre>
<p>And a very simple main:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &quot;throw.h&quot;
int main()
{
    seppuku();
    return 0;
}
</pre>
<p>What happens now if we try to compile and link together this frankencode?</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&amp;gt; g++ -c -o throw.o -O0 -ggdb throw.cpp
&amp;gt; gcc -c -o main.o -O0 -ggdb main.c
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v01">in my github repo</a>.</p>
<p>So far so good. Both g++ and gcc are happy in their little world. Chaos will ensue once we try to link them, though:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&amp;gt; gcc main.o throw.o -o app
throw.o: In function <code>foo()&amp;amp;#x27;:
throw.cpp:4: undefined reference to
</code>__cxa_allocate_exception&amp;#x27;
throw.cpp:4: undefined reference to <code>__cxa_throw&amp;amp;#x27;
throw.o:(.rodata._ZTI9Exception[typeinfo for Exception]+0x0): undefined reference to</code>vtable for __cxxabiv1::__class_type_info&amp;#x27;
collect2: ld returned 1 exit status
</pre>
<p>And sure enough, gcc complains about missing C++ symbols. Those are very special C++ symbols, though. Check the last error line: a vtable for cxxabiv1 is missing. cxxabi, defined in libstdc++, refers to the application binary interface for C++. So now we have learned that the exception handling is done with some help of the standard C++ library with an interface defined by C++&rsquo;s ABI.</p>
<p>The C++ ABI defines a standard binary format so we can link objects together in a single program; if we compile a .o file with two different compilers, and those compilers use a different ABI, we won&rsquo;t be able to link the .o objects into an application. The ABI will also define some other formats, like for example the interface to perform stack unwinding or the throwing of an exception. In this case, the ABI defines an interface (not necessarily a binary format, just an interface) between C++ and some other library in our program which will handle the stack unwinding, ie the ABI defines C++ specific stuff so it can talk to non-C++ libraries: this is what would enable exceptions thrown from other languages to be caught in C++, amongst other things.</p>
<p>In any case, the linker errors are pointing us to the first layer into exception handling under the hood: an interface we&rsquo;ll have to implement ourselves, the cxxabi. For the next article we&rsquo;ll be starting our own mini ABI, as defined in the <a href="/blog/youfoundadeadlink.html">C++ ABI</a>.</p>
<hr />
<h2>C++ exceptions under the hood 3: an ABI to appease the linker<a name="cexceptionsunderthehood3anabitoappeasethelinker"></a></h2>
<p>On our journey to understand exceptions we discovered that the heavy-lifting is done in libstdc++ as specified by the C++ ABI. Reading some linker errors we deduced last time that for handling exceptions we need help from the C++ ABI; we created a throwing C++ program, linked it together with a plain C program and found that the compiler somehow translated our throw instruction into something that is now calling a few libstd++ functions to actually throw an exception. Lost already? You can check the sourcode for this project so far <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v01">in my github repo</a>.</p>
<p>Anyway, we want to understand exactly how an exception is thrown, so we will try to implement our own mini-ABI, capable of throwing an exception. To do this, a lot of <a href="/blog/youfoundadeadlink.html">RTFM</a> is needed, but a full ABI interface can be found <a href="http://libcxxabi.llvm.org/spec.html">here, for LLVM</a>. Let&rsquo;s start by remembering what those missing functions are:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&amp;gt; gcc main.o throw.o -o app
throw.o: In function <code>foo()&amp;amp;#x27;:
throw.cpp:4: undefined reference to
</code>__cxa_allocate_exception&amp;#x27;
throw.cpp:4: undefined reference to <code>__cxa_throw&amp;amp;#x27;
throw.o:(.rodata._ZTI9Exception[typeinfo for Exception]+0x0): undefined reference to</code>vtable for __cxxabiv1::__class_type_info&amp;#x27;
collect2: ld returned 1 exit status
</pre>
<h3>__cxa_allocate_exception<a name="__cxa_allocate_exception"></a></h3>
<p>The name is quite self explanatory, I guess. <strong>__cxa_allocate_exception</strong> receives a size_t and allocates enough memory to hold the exception being thrown. There is more to this that what you would expect: when an exception is being thrown some magic will be happening with the stack, so allocating stuff here is not a good idea. Allocating memory on the heap might also not be a good idea, though, because we might have to throw if we&rsquo;re out of memory. A static allocation is also not a good idea, since we need this to be thread safe (otherwise two throwing threads at the same time would equal disaster). Given these constraints, most implementations seem to allocate memory on a local thread storage (heap) but resort to an emergency storage (presumably static) if out of memory. We, of course, don&rsquo;t want to worry about the ugly details so we can just have a static buffer if we want to.</p>
<h3>__cxa_throw<a name="__cxa_throw"></a></h3>
<p>The function doing all the throw-magic! According to the ABI reference, once the exception has been created <strong>__cxa_throw</strong> will be called. This function will be responsible of starting the stack unwinding. An important effect of this: <strong>__cxa_throw</strong> is never supposed to return. It either delegates execution to the correct catch block to handle the exception or calls (by default) <strong>std::terminate</strong>, but it never ever returns.</p>
<h3>vtable for __cxxabiv1::__class_type_info<a name="vtablefor__cxxabiv1__class_type_info"></a></h3>
<p>A weird one&hellip; __class_type_info is clearly some sort of RTTI, but what exactly? It&rsquo;s not easy to answer this one now and it&rsquo;s not terribly important for our mini ABI; we&rsquo;ll leave it to an appendix for after we are done analyzing the process of throwing exceptions, for now let&rsquo;s just say this is the entry point the ABI defines to know (in runtime) whether two types are the same or not. This is the function that gets called to determine whether a catch(Parent) can handle a throw Child. For now we&rsquo;ll focus on the basics: we need to give it an address for the linker (ie defining it won&rsquo;t be enough, we need to instantiate it) and it has to have a vtable (that is, it must have a virtual method).</p>
<p>Lot&rsquo;s of stuff happen on these functions, but let&rsquo;s try to implement the simplest exception thrower possible: one that will call exit when an exception is thrown. Our application was almost OK but missing some ABI-stuff, so let&rsquo;s create a mycppabi.cpp. Reading <a href="/blog/youfoundadeadlink.html">our ABI specification</a> we can figure out the signatures for <strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw</strong>:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
namespace __cxxabiv1 {
    struct __class_type_info {
        virtual void foo() {}
    } ti;
}
#define EXCEPTION_BUFF_SIZE 255
char exception_buff[EXCEPTION_BUFF_SIZE];
extern &quot;C&quot; {
void<em> __cxa_allocate_exception(size_t thrown_size)
{
    printf(&quot;alloc ex %i\n&quot;, thrown_size);
    if (thrown_size &amp;gt; EXCEPTION_BUFF_SIZE) printf(&quot;Exception too big&quot;);
    return &amp;amp;exception_buff;
}
void __cxa_free_exception(void </em>thrown_exception);
#include &amp;lt;unwind.h&amp;gt;
void __cxa_throw(
          void<em> thrown_exception,
          struct type_info </em>tinfo,
          void (<em>dest)(void</em>))
{
    printf(&quot;throw\n&quot;);
    // __cxa_throw never returns
    exit(0);
}
} // extern &quot;C&quot;
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v01">in my github repo</a>.</p>
<p>If we now compile mycppabi.cpp and link it with the other two .o files, we&rsquo;ll get a working binary which should print &ldquo;alloc ex 1\nthrow&rdquo; and then exit. Pretty simple, but an amazing feat nonetheless: we&rsquo;ve managed to throw an exception without calling libc++. We&rsquo;ve written a (very small) part of a C++ ABI!</p>
<p>Another important bit of wisdom we gained by creating our own mini ABI: the throw keyword is compiled into two function calls to libstdc++. No voodoo there, it&rsquo;s actually a pretty simple transformation. We can even disassemble our throwing function to verify it. Let&rsquo;s run this command &ldquo;g++ -S throw.cpp&rdquo;.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">seppuku:
.LFB3:
    [&hellip;]
    call    __cxa_allocate_exception
    movl    $0, 8(%esp)
    movl    $_ZTI9Exception, 4(%esp)
    movl    %eax, (%esp)
    call    __cxa_throw
    [&hellip;]
</pre>
<p>Even more magic happening: when the throw keyword gets translated into these two calls, the compiler doesn&rsquo;t even know how the exception is going to be handled. Since libstdc++ is the one defining __cxa_throw and friends, and libstdc++ is dynamically linked on runtime, the exception handling method could be chosen when we first run our executable.</p>
<p>We are now seeing some progress but we still have a long way to go. Our ABI can only throw exceptions right now. Can we extend it to handle a catch as well? We&rsquo;ll see how next time.</p>
<hr />
<h2>C++ exceptions under the hood 4: catching what you throw<a name="cexceptionsunderthehood4catchingwhatyouthrow"></a></h2>
<p>In this series about exception handling, we have discovered quite a bit about exception throwing by looking at compiler and linker errors but we have so far not learned anything yet about exception catching. Let&rsquo;s sum up the few things we learned about exception throwing:</p>
<ul>
<li>A throw statement will be translated by the compiler into two calls, <strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw</strong>.</li>
<li><strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw</strong> &ldquo;live&rdquo; on libstdc++</li>
<li><strong>__cxa_allocate_exception</strong> will allocate memory for the new exception.</li>
<li><strong>__cxa_throw</strong> will prepare a bunch of stuff and forward this exception to <strong>_Unwind_</strong>, a set of functions that live in libstdc and perform the real stack unwinding (<a href="/blog/youfoundadeadlink.html">the ABI</a> defines the interface for these functions).</li>
</ul>
<p>Quite simple so far, but exception catching is a bit more complicated, specially because it requires certain degree of reflexion (that is, the ability of a program to analyze its own source code). Let&rsquo;s keep on trying our same old method, let&rsquo;s add some catch statements throughout our code, compile it and see what happens:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &quot;throw.h&quot;
#include &amp;lt;stdio.h&amp;gt;
// Notice we&amp;#x27;re adding a second exception type
struct Fake_Exception {};
void raise() {
    throw Exception();
}
// We will analyze what happens if a try block doesn&amp;#x27;t catch an exception
void try_but_dont_catch() {
    try {
        raise();
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Running try_but_dont_catch::catch(Fake_Exception)\n&quot;);
    }
    printf(&quot;try_but_dont_catch handled an exception and resumed execution&quot;);
}
// And also what happens when it does
void catchit() {
    try {
        try_but_dont_catch();
    } catch(Exception&amp;amp;) {
        printf(&quot;Running try_but_dont_catch::catch(Exception)\n&quot;);
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Running try_but_dont_catch::catch(Fake_Exception)\n&quot;);
    }
    printf(&quot;catchit handled an exception and resumed execution&quot;);
}
extern &quot;C&quot; {
    void seppuku() {
        catchit();
    }
}
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v02">in my github repo</a>.</p>
<p>Just like before, we have our seppuku function linking the C world with the C++ world, only this time we have added some more function calls to make our stack more interesting, plus we have added a bunch of try/catch blocks so we can analyze how does libstdc++ handles them.</p>
<p>And just like before, we get some linker errors about missing ABI functions:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&amp;gt; g++ -c -o throw.o -O0 -ggdb throw.cpp
&amp;gt; gcc main.o throw.o mycppabi.o -O0 -ggdb -o app
throw.o: In function <code>try_but_dont_catch()&amp;amp;#x27;:
throw.cpp:12: undefined reference to
</code>__cxa_begin_catch&amp;#x27;
throw.cpp:12: undefined reference to <code>__cxa_end_catch&amp;amp;#x27;
throw.o: In function</code>catchit()&amp;#x27;:
throw.cpp:20: undefined reference to <code>__cxa_begin_catch&amp;amp;#x27;
throw.cpp:20: undefined reference to</code>__cxa_end_catch&amp;#x27;
throw.o:(.eh_frame+0x47): undefined reference to `__gxx_personality_v0&amp;#x27;
collect2: ld returned 1 exit status
</pre>
<p>Again we see a lot of interesting stuff going on here. The calls to <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch</strong> are probably something we could have expected: we don&rsquo;t know what they are yet, but we can presume they are the equivalent of the <strong>throw/__cxa_allocate/throw</strong> conversions (you do remember that our throw keyword got translated to a pair of <strong>__cxa_allocate_exception</strong> and <strong>__cxa_throw functions</strong>, right?). The <strong>__gxx_personality_v0</strong> thing is new, though, and the central piece of the next few articles.</p>
<p>What does the personality function do? We already said something about it on the introduction to this series but we will be looking into it with some more detail next time, together with our new two friends, <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch</strong>.</p>
<hr />
<h2>C++ exceptions under the hood 5: magic around __cxa_begin_catch and __cxa_end_catch<a name="cexceptionsunderthehood5magicaround__cxa_begin_catchand__cxa_end_catch"></a></h2>
<p>After learning how exceptions are thrown we are now on our way to learn how they are caught. Last time we added to our example application a bunch of try/catch statements to see what they did, and sure enough we got a bunch of linker errors, just like we did when we were trying to find out what does the throw statement do. This is what the linker says when trying to process throw.o:</p>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v02">in my github repo</a>.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&amp;gt; g++ -c -o throw.o -O0 -ggdb throw.cpp
&amp;gt; gcc main.o throw.o mycppabi.o -O0 -ggdb -o app
throw.o: In function <code>try_but_dont_catch()&amp;amp;#x27;:
throw.cpp:12: undefined reference to
</code>__cxa_begin_catch&amp;#x27;
throw.cpp:12: undefined reference to <code>__cxa_end_catch&amp;amp;#x27;
throw.o: In function</code>catchit()&amp;#x27;:
throw.cpp:20: undefined reference to <code>__cxa_begin_catch&amp;amp;#x27;
throw.cpp:20: undefined reference to</code>__cxa_end_catch&amp;#x27;
throw.o:(.eh_frame+0x47): undefined reference to `__gxx_personality_v0&amp;#x27;
collect2: ld returned 1 exit status
</pre>
<p>And our theory, of course, is that a catch statement is translated by the compiler into a pair of <strong>__cxa_begin_catch/end_catch</strong> calls into libstdc++, plus something new called <strong>the personality function</strong> of which we know nothing yet.</p>
<p>Let&rsquo;s begin by checking if our theory about <strong>__cxa_begin_catch</strong> and <strong>__cxa_end_catch holds</strong>. Let&rsquo;s compile throw.cpp with -S and analyze the assembly. There is a lot to see but if I strip it to the bare minimum this is what I get:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">_Z5raisev:
    call    __cxa_allocate_exception
    call    __cxa_throw
</pre>
<p>So far so good: the same old definition we got for raise(), just throw an exception.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">_Z18try_but_dont_catchv:
    .cfi_startproc
    .cfi_personality 0,__gxx_personality_v0
    .cfi_lsda 0,.LLSDA1
</pre>
<p>The definition for try_but_dont_catch(), mangled by the compiler. There is something new, though: a reference to <strong>__gxx_personality_v0</strong> and to something else called <strong>LSDA</strong>. These are seemingly innocent declarations but they are actually quite important:</p>
<ul>
<li>The linker will use these according to a CFI specification; CFI stands for call frame information, and <a href="http://www.logix.cz/michal/devel/gas-cfi/">here</a> there is a full spec for it. It will be used, mostly, to unwind the stack.</li>
<li><strong>LSDA</strong> on the other hand means language specific data area, and it will be used by the personality function to know which exceptions can be handled by this function</li>
</ul>
<p>We&rsquo;ll be talking a lot more about CFI and LSDA in the next articles; don&rsquo;t forget about them, but for now let&rsquo;s move on:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">    [&hellip;]
    call    _Z5raisev
    jmp .L8
</pre>
<p>Another easy one: just call &ldquo;raise&rdquo;, and then jump to L8; L8 will return normally from this function. If raise didn&rsquo;t execute properly then the execution (somehow, we don&rsquo;t know how yet!) shouldn&rsquo;t resume in the next instruction but in the exception handlers (which in ABI-speak are called landing pads. More on that later).</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">    cmpl    $1, %edx
    je  .L5
.LEHB1:
    call    _Unwind_Resume
.LEHE1:
.L5:
    call    __cxa_begin_catch
    call    __cxa_end_catch
</pre>
<p>This is quite difficult to follow but it&rsquo;s actually quite straight forward. Here most of the magic will happen: first we check if this is an exception we can handle, if we can&rsquo;t then we say so by calling _Unwind_Resume, if it is then we call __cxa_begin_catch and __cxa_end_catch; after calling these functions the execution should resume normally and thus L8 will be executed (that is, L8 is right below our catch block):</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.L8:
    leave
    .cfi_restore 5
    .cfi_def_cfa 4, 4
    ret
    .cfi_endproc
</pre>
<p>Just a normal return from our function&hellip; with some CFI stuff on it.</p>
<p>So this is it for exception catching, although we don&rsquo;t know yet how <strong>__cxa_begin/end_catch</strong> work, we have an idea that these pair forms what&rsquo;s called a landing pad, a place in the function to handle the raised exception. What we don&rsquo;t know yet is how the landing pads are found. _Unwind_ must somehow go through all the calls in the stack, check if any call (stack frame, to be precise) has a valid try block with a landing pad that can catch the exception, and then resume the execution there.</p>
<p>This is no small feat, and we&rsquo;ll see how that works next time.</p>
<hr />
<h2>C++ exceptions under the hood 6: gcc_except_table and the personality function<a name="cexceptionsunderthehood6gcc_except_tableandthepersonalityfunction"></a></h2>
<p>We learned last time that, just as a throw statement is translated into a pair of <strong>__cxa_allocate_exception/throw</strong> calls, a catch block is translated into a pair of <strong>__cxa_begin/end_catch</strong> calls, plus something called CFI (call frame information) to find the landing pads, the points on a function where an exception can be handled.</p>
<p>What we don&rsquo;t yet know is how does _Unwind_* know where the landing pads are. When an exception is thrown there are a bunch of functions in the stack; all the CFI stuff will let Unwind know which functions these are but it&rsquo;s also necessary to know which landing pads each function provides so we can call each one and check if it wants to handle the exception (and we&rsquo;re ignoring functions with multiple try/catch blocks!).</p>
<p>To know where the landing pads are, something called gcc_except_table is used. This can be found (with a bunch of CFI stuff) after the function&rsquo;s end:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.LFE1:
    .globl  __gxx_personality_v0
    .section    .gcc_except_table,&quot;a&quot;,@progbits
    [&hellip;]
.LLSDACSE1:
    .long   _ZTI14Fake_Exception
</pre>
<p>The section .gcc_except_table is where all information to locate a landing pad is stored, and we&rsquo;ll see more about it once we get to analyzing the personality function; for now, we&rsquo;ll just say that LSDA means language specific data area and it&rsquo;s the place where the personality function will check if there are any landing pads for a function (it is also used to run the destructors when unwinding the stack).</p>
<p>To wrap it up: for every function where at least a catch is found, the compiler will translate this statement into a pair of <strong>__cxa_begin_catch/__cxa_end_catch</strong> calls and then the personality function, which will be called by <strong>__cxa_throw</strong>, will read the gcc_except_table for every method in the stack, to find something call LSDA. The personality function will then check in the LSDA whether a catch can handle an exception and if there is any cleanup code to run (this is what triggers the destructors when needed).</p>
<p>We can also draw an interesting conclusion here: if we use the nothrow specifier (or the empty throw specifier) then the compiler can omit the gcc_except_table for this method. The way gcc implements exceptions, that won&rsquo;t have a great impact on performance but it will indeed reduce code size. What&rsquo;s the catch? If an exception is thrown when nothrow was specified the LSDA won&rsquo;t be there and the personality function won&rsquo;t know what to do. When the personality function doesn&rsquo;t know what to do it will invoke the default exception handler, meaning that in most cases throwing from a nothrow method will end up calling std::terminate.</p>
<p>Now that we have an idea of what the personality function does, can we implement one? We&rsquo;ll see how next time.</p>
<hr />
<h2>C++ exceptions under the hood 7: a nice personality<a name="cexceptionsunderthehood7anicepersonality"></a></h2>
<p>On our journey to learn about exceptions we have learned so far how a throw is done, that something called &ldquo;call frame information&rdquo; helps a library called Unwind to do the stack unwinding, and that the compiler writes something called LSDA, language specific data area, to know which exceptions can a method handle. And we know by now that a lot of magic is done on the personality function; we&rsquo;ve never seen it in action though. Let&rsquo;s recap in a bit more of detail about how an exception will be thrown and caught (or, more precisely, how we know so far it will be thrown caught):</p>
<ul>
<li>The compiler will translate our throw statement into a pair of <strong>__cxa_allocate_exception/__cxa_throw</strong></li>
<li><strong>__cxa_allocate_exception</strong> will create the exception in memory</li>
<li><strong>__cxa_throw</strong> will initialize a bunch of stuff and forward this exception to a lower-level unwind library by calling <strong>_Unwind_RaiseException</strong></li>
<li>Unwind will use CFI to know which functions are on the stack (ie to know how to start the stack unwinding)</li>
<li>Each function will have an LSDA (language specific data area) part, added into something called <strong>&ldquo;.gcc_except_table&rdquo;</strong></li>
<li>Unwind will invoke the personality function with the current stack frame and the LSDA; this function should reply to unwind whether this stack can handle the exception or not</li>
</ul>
<p>Knowing this, it&rsquo;s about time we implement our own personality function. Our ABI used to print this when an exception was thrown:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">alloc ex 1
__cxa_throw called
no one handled __cxa_throw, terminate!
</pre>
<p>Let&rsquo;s go back to our mycppabi and let&rsquo;s add something like this (link to full mycppabi.cpp file):</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void __gxx_personality_v0()
{
    printf(&quot;Personality function FTW\n&quot;);
}
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v02">in my github repo</a>.</p>
<p>And sure enough, when we run it we should see our personality function being called. We know we&rsquo;re on the right track and now we have an idea of what we want for our personality function; let&rsquo;s start using the proper definition for this function:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">_Unwind_Reason_Code __gxx_personality_v0 (
                     int version, _Unwind_Action actions, uint64_t exceptionClass,
                     _Unwind_Exception<em> unwind_exception, _Unwind_Context</em> context);
</pre>
<p>If we put that into our mycppabi.cpp file we get:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
namespace __cxxabiv1 {
    struct __class_type_info {
        virtual void foo() {}
    } ti;
}
#define EXCEPTION_BUFF_SIZE 255
char exception_buff[EXCEPTION_BUFF_SIZE];
extern &quot;C&quot; {
void<em> __cxa_allocate_exception(size_t thrown_size)
{
    printf(&quot;alloc ex %i\n&quot;, thrown_size);
    if (thrown_size &amp;gt; EXCEPTION_BUFF_SIZE) printf(&quot;Exception too big&quot;);
    return &amp;amp;exception_buff;
}
void __cxa_free_exception(void </em>thrown_exception);
#include &amp;lt;unwind.h&amp;gt;
typedef void (<em>unexpected_handler)(void);
typedef void (</em>terminate_handler)(void);
struct __cxa_exception {
    std::type_info *    exceptionType;
    void (<em>exceptionDestructor) (void </em>);
    unexpected_handler  unexpectedHandler;
    terminate_handler   terminateHandler;
    __cxa_exception *   nextException;
    int         handlerCount;
    int         handlerSwitchValue;
    const char *        actionRecord;
    const char *        languageSpecificData;
    void *          catchTemp;
    void *          adjustedPtr;
    _Unwind_Exception   unwindHeader;
};
void __cxa_throw(void<em> thrown_exception, struct type_info </em>tinfo, void (<em>dest)(void</em>))
{
    printf(&quot;__cxa_throw called\n&quot;);
    __cxa_exception <em>header = ((__cxa_exception </em>) thrown_exception - 1);
    _Unwind_RaiseException(&amp;amp;header-&amp;gt;unwindHeader);
    // __cxa_throw never returns
    printf(&quot;no one handled __cxa_throw, terminate!\n&quot;);
    exit(0);
}
void __cxa_begin_catch()
{
    printf(&quot;begin FTW\n&quot;);
}
void __cxa_end_catch()
{
    printf(&quot;end FTW\n&quot;);
}
_Unwind_Reason_Code __gxx_personality_v0 (
                     int version, _Unwind_Action actions, uint64_t exceptionClass,
                     _Unwind_Exception<em> unwind_exception, _Unwind_Context</em> context)
{
    printf(&quot;Personality function FTW!\n&quot;);
}
}
</pre>
<p>Code @ <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v02">my github repo</a>.</p>
<p>Let&rsquo;s compile and link everything, then run it and start by analyzing each param to this function with some help of gdb:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">Breakpoint 1, __gxx_personality_v0 (version=1, actions=1, exceptionClass=134514792, unwind_exception=0x804a060, context=0xbffff0f0)
</pre>
<ul>
<li>The version and the exceptionClass are related to language/ABI/compiler toolchain/native or non-native exception, etc. We don&rsquo;t need to worry about it for our mini ABI, we&rsquo;ll just handle all the exceptions.</li>
<li>Actions: this is what _Unwind_ uses to tell the personality function what it should do (more on that later)</li>
<li>unwind_exception: the exception allocated by __cxa_allocate_exception (kind of&hellip; there&rsquo;s a lot of pointer arithmetic going on but that pointer can be used to access our original exception anyway)</li>
<li>context: this holds all the information regarding the current stack frame, for example the language specific data area (LSDA). This is what we will be using to detect whether this stack can handle the thrown exception (and also to detect whether we need to run any destructors)</li>
</ul>
<p>So there we have it, a working (well, linkeable) personality function. Doesn&rsquo;t do much, though, so next time we&rsquo;ll start adding some real behavior and try to make it handle an exception.</p>
<hr />
<h2>C++ exceptions under the hood 8: two-phase handling<a name="cexceptionsunderthehood8twophasehandling"></a></h2>
<p>We finished last chapter on the series about C++ exceptions by adding a personality function that _Unwind_ was able to call. It didn&rsquo;t do much but there it was. The ABI we have been implementing can now throw exceptions and the catch is already halfway implemented, but the personality function needed to properly choose the catch block (landing pad) is bit dumb so far. Let&rsquo;s start this new chapter by trying to understand what are the parameters that the personality function receives and next time we&rsquo;ll begin adding some real behavior to __gxx_personality_v0: when __gxx_personality_v0 is called we should say &ldquo;yes, this stack frame can indeed handle this exception&rdquo;.</p>
<p>We already said we won&rsquo;t care for the version or the exceptionClass for our mini ABI. Let&rsquo;s ignore the context too, for now: we&rsquo;ll just handle every exception with the first stack frame above the function throwing; note this implies there must be a try/catch block on the function immediately above the throwing function, otherwise everything will break. This also implies the catch will ignore its exception specification, effectively turning it into a catch(&hellip;). How do we let _Unwind_ know we want to handle the current exception?</p>
<p>_Unwind_Reason_Code is the return value from the personality functions; this tells _Unwind_ whether we found a landing pad to handle the exception or not. Let&rsquo;s implement our personality function to return _URC_HANDLER_FOUND then, and see what happens:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">alloc ex 1
__cxa_throw called
Personality function FTW
Personality function FTW
no one handled __cxa_throw, terminate!
</pre>
<p>See that? We told _Unwind_ we found a handler, and it called the personality function yet again! What is going on there?</p>
<p>Remember the action parameter? That&rsquo;s how _Unwind_ tells us what he is expecting, and that is because the exception catching is handled in two phases: lookup and cleanup (or _UA_SEARCH_PHASE and _UA_CLEANUP_PHASE). Let&rsquo;s go again over our exception throwing and catching recipe:</p>
<ul>
<li>__cxa_throw/__cxa_allocate_exception will create an exception and forward it to a lower-level unwind library by calling _Unwind_RaiseException</li>
<li>Unwind will use CFI to know which functions are on the stack (ie to know how to start the stack unwinding)</li>
<li>Each function has have an LSDA (language specific data area) part, added into something called &ldquo;.gcc_except_table&rdquo;</li>
<li>Unwind will try to locate a landing pad for the exception:<ul>
<li>Unwind will call the personality function with the action _UA_SEARCH_PHASE and a context pointing to the current stack frame.</li>
<li>The personality function will check if the current stack frame can handle the exception being thrown by analyzing the LSDA.</li>
<li>If the exception can be handled it will return _URC_HANDLER_FOUND.</li>
<li>If the exception can not be handled it will return _URC_CONTINUE_UNWIND and Unwind will then try the next stack frame.</li>
</ul>
</li>
<li>If no landing pad was found, the default exception handler will be called (normally std::terminate).</li>
<li>If a landing pad was found:<ul>
<li>Unwind will iterate the stack again, calling the personality function with the action _UA_CLEANUP_PHASE.</li>
<li>The personality function will check if it can handle the current exception again:</li>
<li>If this frame can&rsquo;t handle the exception it will then run a cleanup function described by the LSDA and tell Unwind to continue with the next frame (this is actually a very important step: the cleanup function will run the destructor of all the objects allocated in this stack frame!)</li>
<li>If this frame can handle the exception, don&rsquo;t run any cleanup code: tell Unwind we want to resume execution on this landing pad.</li>
</ul>
</li>
</ul>
<p>There are two important bits of information to note here:
1. Running a two-phase exception handling procedure means that in case no handler was found then the default exception handler can get the original exception&rsquo;s stack trace (if we were to unwind the stack as we go it would get no stack trace, or we would need to keep a copy of it somehow!).
2. Running a _UA_CLEANUP_PHASE and calling a second time each frame, even though we already know the frame that will handle the exception, is also really important: the personality function will take this chance to run all the destructors for objects built on this scope. It is what makes RAII an exception safe idiom!</p>
<p>Now that we understand how the catch lookup phase works we can continue our personality function implementation. The next time.</p>
<hr />
<h2>C++ exceptions under the hood 9: catching our first exception<a name="cexceptionsunderthehood9catchingourfirstexception"></a></h2>
<p>We finished last chapter on the series about C++ exceptions by adding a personality function that _Unwind_ was able to call and then analyzing the parameters that the personality function receives. Now it&rsquo;s time to begin adding some real behavior to __gxx_personality_v0: when __gxx_personality_v0 is called we should say &ldquo;yes, this stack frame can indeed handle this exception&rdquo;.</p>
<p>We have been building up to this point quite a bit: the time where we can implement for the first time a personality function capable of detecting when an exception is thrown, and then saying &ldquo;yes, I will handle this exception&rdquo;. For that we had to learn how the two-phase lookup work, so we can now reimplement our personality function and our throw test file:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;stdio.h&amp;gt;
#include &quot;throw.h&quot;
struct Fake_Exception {};
void raise() {
    throw Exception();
}
void try_but_dont_catch() {
    try {
        raise();
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Caught a Fake_Exception!\n&quot;);
    }
    printf(&quot;try_but_dont_catch handled the exception\n&quot;);
}
void catchit() {
    try {
        try_but_dont_catch();
    } catch(Exception&amp;amp;) {
        printf(&quot;Caught an Exception!\n&quot;);
    }
    printf(&quot;catchit handled the exception\n&quot;);
}
extern &quot;C&quot; {
    void seppuku() {
        catchit();
    }
}
</pre>
<p>And our personality function:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">_Unwind_Reason_Code __gxx_personality_v0 (
                     int version, _Unwind_Action actions, uint64_t exceptionClass,
                     _Unwind_Exception<em> unwind_exception, _Unwind_Context</em> context)
{
    if (actions &amp;amp; _UA_SEARCH_PHASE)
    {
        printf(&quot;Personality function, lookup phase\n&quot;);
        return _URC_HANDLER_FOUND;
    } else if (actions &amp;amp; _UA_CLEANUP_PHASE) {
        printf(&quot;Personality function, cleanup\n&quot;);
        return _URC_INSTALL_CONTEXT;
    } else {
        printf(&quot;Personality function, error\n&quot;);
        return _URC_FATAL_PHASE1_ERROR;
    }
}
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v03">in my github repo</a>.</p>
<p>Let&rsquo;s run it, see what happens:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">alloc ex 1
__cxa_throw called
Personality function, lookup phase
Personality function, cleanup
try_but_dont_catch handled the exception
catchit handled the exception
</pre>
<p>It works, but something is missing: the catch inside the catch/try block is not being executed! This is happening because the personality function tells Unwind to &ldquo;install a context&rdquo; (ie to resume execution) but it never says which context. In this case it&rsquo;s probably resuming executing from after the landing pad, but I&rsquo;d bet this is actually undefined behavior. We&rsquo;ll see next time how we can specify we want to resume executing from a specific landing pad using the information available on .gcc_except_table (our old friend, the LSDA).</p>
<hr />
<h2>C++ exceptions under the hood 10: _Unwind_ and call frame info<a name="cexceptionsunderthehood10_unwind_andcallframeinfo"></a></h2>
<p>We left our mini-ABI project (<a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v03">link</a>) capable of throwing exceptions, and we are now working on catching them; we implemented a personality function last time which was capable of detecting and handling exceptions but it was still a bit incomplete: even though it can properly notify the stack unwinder when it should stop but our version of __gxx_personality_v0 can&rsquo;t run the code inside a catch block. It&rsquo;s better than a coredump one might argue, but still a long way from a useful exception handling ABI. Can we improve it?</p>
<p>How can we tell _Unwind_ where is our landing pad, so we can execute the code inside the catch statement? If we go back to the <a href="/blog_md/youfoundadeadlink.md#base-om">ABI specification</a>, there are a few context management functions which might help us:</p>
<ul>
<li>_Unwind_GetLanguageSpecificData, to get the LSDA for this stack frame. We should be able to find the landing pads and the destructors to run using it.</li>
<li>_Unwind_GetRegionStart, to get the instruction pointer for the beginning of the function for stack frame currently under analysis by the personality function (that is, the function pointer for the current stack frame).</li>
<li>_Unwind_GetIP, to get the instruction pointer inside the current stack frame (a pointer to the place where the function call to the next stack frame was done. It should be clearer with the example below).</li>
</ul>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v04">in my github repo</a>.</p>
<p>Let&rsquo;s check these functions with gdb. On my machine:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">Breakpoint 1, __gxx_personality_v0 (version=1, actions=6, exceptionClass=134515400, unwind_exception=0x804a060, context=0xbffff0f0)
    at mycppabi.cpp:77
84          const uint8_t<em> lsda = (const uint8_t</em>)_Unwind_GetLanguageSpecificData(context);
85          uintptr_t ip = _Unwind_GetIP(context) - 1;
86          uintptr_t funcStart = _Unwind_GetRegionStart(context);
87          uintptr_t ipOffset = ip - funcStart;
</pre>
<p>If we inspect those variables we can see that indeed _Unwind_GetRegionStart points to the current stack frame (try_but_dont_catch) and that _Unwind_GetIP is the IP for the position where the call to the next stack frame was done. The _Unwind_GetRegionStart is pointing us to the place where the exception was first thrown; it&rsquo;s a bit complicated to explain and we&rsquo;ll use that later, not now. Also, we don&rsquo;t see the LSDA here, but we can deduce it&rsquo;s after the function&rsquo;s code since _Unwind_GetLanguageSpecificData points directly after the function&rsquo;s end:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">_Unwind_GetIP = (void <em>) 0x804861d
_Unwind_GetRegionStart = (void </em>) 0x8048612
_Unwind_GetLanguageSpecificData = (void *) 0x8048e3c
function pointer to try_but_dont_catch = 0x8048612 &amp;lt;try_but_dont_catch()&amp;gt;
(gdb) disassemble /m try_but_dont_catch
Dump of assembler code for function try_but_dont_catch():
10  void try_but_dont_catch() {
        [&hellip;]
11      try {
12          raise();
   0x08048619 &amp;lt;+7&amp;gt;:   call   0x80485e8 &amp;lt;raise()&amp;gt;
13      } catch(Fake_Exception&amp;amp;) {
   0x08048651 &amp;lt;+63&amp;gt;:  call   0x804874a &amp;lt;__cxa_begin_catch()&amp;gt;
   0x08048665 &amp;lt;+83&amp;gt;:  call   0x804875e &amp;lt;__cxa_end_catch()&amp;gt;
   0x0804866a &amp;lt;+88&amp;gt;:  jmp    0x804861e &amp;lt;try_but_dont_catch()+12&amp;gt;
14          printf(&quot;Caught a Fake_Exception!\n&quot;);
   0x08048659 &amp;lt;+71&amp;gt;:  movl   $0x8048971,(%esp)
   0x08048660 &amp;lt;+78&amp;gt;:  call   0x80484c0 &amp;lt;puts@plt&amp;gt;
15      }
16
17      printf(&quot;try_but_dont_catch handled the exception\n&quot;);
   0x0804861e &amp;lt;+12&amp;gt;:  movl   $0x8048948,(%esp)
   0x08048625 &amp;lt;+19&amp;gt;:  call   0x80484c0 &amp;lt;puts@plt&amp;gt;
18  }
   0x0804862a &amp;lt;+24&amp;gt;:  add    $0x24,%esp
</pre>
<p>With the help of _Unwind_ we are now able to get enough information about the current stack frame to decide whether we can or not handle an exception, an also how should we handle it. One more step is needed before we can detect the landing pad we want: we will need to interpret the CFI (call frame information) at the end of the function. This is part of the DWARF spec, the same gdb uses for debugging purposes, and it&rsquo;s not an easy spec to implement. Like we are doing with our ABI, we&rsquo;ll keep this to the bare minimum.</p>
<hr />
<h2>C++ exceptions under the hood 11: reading a CFI table<a name="cexceptionsunderthehood11readingacfitable"></a></h2>
<p>To properly handle exceptions from within the personality function we&rsquo;ve been implementing for our ABI, we need to read the LSDA (language specific data area) to know which call frame (ie which function) can handle which exception, and to know where a landing pad (catch block) can be found). The LSDA table is in CFI format, and we&rsquo;ll see in this chapter how to read it.</p>
<p>Reading the CFI data can be rather straight forward, but there are a few pitfalls we need to consider first. Two, actually:
1. There is very little documentation about the .gcc_except_table format (actually, I only found some mails about it) so we&rsquo;ll need to read a lot of source code and disassembles to understand it.
2. Although the format itself is not terribly complicated, it uses a LEB encoding that makes reading this table not quite straightforward.</p>
<p>As far as I know most DWARF data is encoded like this, using a <a href="http://en.wikipedia.org/wiki/LEB128">LEB format</a>, which seems to be great for confusing programmers and to save code space while encoding arbitrary length ints. Luckily, we can cheat a bit in here: most of the time the LEB encoded numbers will readble with a plain uint8_t, because we won&rsquo;t be dealing with large exception tables or anything like that.</p>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v04">in my github repo</a>.</p>
<p>Let&rsquo;s start by analyzing the CFI data directly from the disassembly, we&rsquo;ll then see if we can build something to read it on our personality function. I&rsquo;ll rename the labels to make them a bit more human-friendly. The LSDA will have three sections, try to spot them below:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.local_frame_entry:
    .globl  __gxx_personality_v0
    .section    .gcc_except_table,&quot;a&quot;,@progbits
    .align 4
</pre>
<p>This one is very easy: it&rsquo;s just a header to declare we&rsquo;re going to use __gxx_personality_v0 as a global and to let the linker know we&rsquo;re going to be declaring stuff for the .gcc_except_table section. Moving on:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.local_lsda_1:
    # This declares the encoding type. We don&amp;#x27;t care.
    .byte   0xff
    # This specifies the landing pads start; if zero, the func&amp;#x27;s ptr is
    # assumed (_Unwind_GetRegionStart)
    .byte   0
    # Length of the LSDA area: check that LLSDATT1 and LLSDATTD1 point to the
    # end and the beginning of the LSDA, respectively
    .uleb128 .local_lsda_end - .local_lsda_call_site_table_header
</pre>
<p>This now has some more info. Those labels are quite obscure but they do follow a pattern. LSDA means language specific data area, the L in front means local, so this is the local (to the translation unit, the .o file) language specific data area number one. Other labels follow similar patterns but I haven&rsquo;t taken the job of figuring them out. We don&rsquo;t really need to, anyway.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.local_lsda_call_site_table_header:
    # Encoding of items in the landing pad table. Again, we don&amp;#x27;t care.
    .byte   0x1.
    # The length of the call site table (ie the landing pads)
    .uleb128 .local_lsda_call_site_table_end - .local_lsda_call_site_table
</pre>
<p>Another boring header. Moving on:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.local_lsda_call_site_table:
    .uleb128 .LEHB0-.LFB1
    .uleb128 .LEHE0-.LEHB0
    .uleb128 .L8-.LFB1
    .uleb128 0x1
    .uleb128 .LEHB1-.LFB1
    .uleb128 .LEHE1-.LEHB1
    .uleb128 0
    .uleb128 0
    .uleb128 .LEHB2-.LFB1
    .uleb128 .LEHE2-.LEHB2
    .uleb128 .L9-.LFB1
    .uleb128 0
.local_lsda_call_site_table_end:
</pre>
<p>This is much more interesting, now we&rsquo;re seeing the call site table itself. Somehow, in all these entries, we should be able to find our landing pad. According to some random internet page, the format for each call site entry should be:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct lsda_call_site_entry {
    // Start of the IP range
    size_t cs_start;
    // Length of the IP range
    size_t cs_len;
    // Landing pad address
    size_t cs_lp;
    // Offset into action table
    size_t cs_action;
};
</pre>
<p>So we seem to be on the right track, though we don&rsquo;t know yet why there are 3 call site entries when we only defined a single landing pad. In any case, we can cheat a little: by looking at the disassembly we can deduce that all the values on the CFI will be less than 128 and this means that in LEB encoding they can be read as plain uchars. This makes our CFI reading code so much easier, and we will see how to use it in our personality function next time.</p>
<hr />
<h2>C++ exceptions under the hood 12: and suddenly, reflexion in C++<a name="cexceptionsunderthehood12andsuddenlyreflexioninc"></a></h2>
<p>We left our mini-ABI project (<a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v03">link</a>) capable of throwing exceptions, and we are now working on catching them; we implemented a personality function last time which was capable of detecting and handling exceptions but it was still a bit incomplete: even though it can properly notify the stack unwinder when it should stop but our version of __gxx_personality_v0 can&rsquo;t run the code inside a catch block. We learned last time how to read the LSDA, so now it&rsquo;s only a problem of putting all the pieces together to read the .gcc_except_table from within our personality function.</p>
<p>Let&rsquo;s recap a bit: we figured out last time that our LSDA for the function which has the catch we want to run has the following call site table (that is, the following landing pads [that is, the following catch blocks]):</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.local_lsda_call_site_table:
    .uleb128 .LEHB0-.LFB1
    .uleb128 .LEHE0-.LEHB0
    .uleb128 .L8-.LFB1
    .uleb128 0x1
    .uleb128 .LEHB1-.LFB1
    .uleb128 .LEHE1-.LEHB1
    .uleb128 0
    .uleb128 0
    .uleb128 .LEHB2-.LFB1
    .uleb128 .LEHE2-.LEHB2
    .uleb128 .L9-.LFB1
    .uleb128 0
.local_lsda_call_site_table_end:
</pre>
<p>All those labels can be mapped to different places in the assembly of our function, but it&rsquo;s a bit too messy for a blog post (I do recommend you to disassemble the function yourself and try to match each label, a lot can be learned from doing it). Also, thanks to some random Internet page, we learned the format for this table.</p>
<p>Let&rsquo;s do something like this to see if we&rsquo;re on the right track (beware of read-alignment issues and keep in mind that defining CFI structures like this will only work for uint8&rsquo;s and is probably not portable):</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct LSDA_Header {
    uint8_t lsda_start_encoding;
    uint8_t lsda_type_encoding;
    uint8_t lsda_call_site_table_length;
};
struct LSDA_Call_Site_Header {
    uint8_t encoding;
    uint8_t length;
};
struct LSDA_Call_Site {
    LSDA_Call_Site(const uint8_t <em>ptr) {
        cs_start = ptr[0];
        cs_len = ptr[1];
        cs_lp = ptr[2];
        cs_action = ptr[3];
    }
    uint8_t cs_start;
    uint8_t cs_len;
    uint8_t cs_lp;
    uint8_t cs_action;
};
_Unwind_Reason_Code __gxx_personality_v0 (
                     int version, _Unwind_Action actions, uint64_t exceptionClass,
                     _Unwind_Exception</em> unwind_exception, _Unwind_Context<em> context)
{
    if (actions &amp;amp; _UA_SEARCH_PHASE)
    {
        printf(&quot;Personality function, lookup phase\n&quot;);
        return _URC_HANDLER_FOUND;
    } else if (actions &amp;amp; _UA_CLEANUP_PHASE) {
        printf(&quot;Personality function, cleanup\n&quot;);
        const uint8_t</em> lsda = (const uint8_t<em>)
                                    _Unwind_GetLanguageSpecificData(context);
        LSDA_Header </em>header = (LSDA_Header<em>)(lsda);
        LSDA_Call_Site_Header </em>cs_header = (LSDA_Call_Site_Header<em>)
                                                (lsda + sizeof(LSDA_Header));
        size_t cs_in_table = cs_header-&amp;gt;length / sizeof(LSDA_Call_Site);
        // We must declare cs_table_base as uint8, otherwise we risk an
        // unaligned access
        const uint8_t </em>cs_table_base = lsda + sizeof(LSDA_Header)
                                            + sizeof(LSDA_Call_Site_Header);
        // Go through every entry on the call site table
        for (size_t i=0; i &amp;lt; cs_in_table; ++i)
        {
            const uint8_t *offset = &amp;amp;cs_table_base[i * sizeof(LSDA_Call_Site)];
            LSDA_Call_Site cs(offset);
            printf(&quot;Found a CS:\n&quot;);
            printf(&quot;\tcs_start: %i\n&quot;, cs.cs_start);
            printf(&quot;\tcs_len: %i\n&quot;, cs.cs_len);
            printf(&quot;\tcs_lp: %i\n&quot;, cs.cs_lp);
            printf(&quot;\tcs_action: %i\n&quot;, cs.cs_action);
        }
        uintptr_t ip = _Unwind_GetIP(context);
        uintptr_t funcStart = _Unwind_GetRegionStart(context);
        uintptr_t ipOffset = ip - funcStart;
        return _URC_INSTALL_CONTEXT;
    } else {
        printf(&quot;Personality function, error\n&quot;);
        return _URC_FATAL_PHASE1_ERROR;
    }
}
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v05">in my github repo</a>.</p>
<p>As you can see if you run this code, all entries in the call site table are relative. Relative to what? To the start of function. That means that if we want to get the EIP for a specific landing pad all we have to do is _Unwind_GetRegionStart + LSDA_Call_Site.cs_lp!</p>
<p>We should now be able to solve our exceptional problem: let&rsquo;s try to modify our personality function to run the correct landing pad. We&rsquo;ll now need to use another _Unwind_ function to specify where we want to resume execution: _Unwind_SetIP. Let&rsquo;s change the personality function again to run the first landing pad available, which by inspecting the assembly we already know is the one we want:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">        &hellip;
        const uint8_t <em>cs_table_base = lsda + sizeof(LSDA_Header)
                                            + sizeof(LSDA_Call_Site_Header);
        for (size_t i=0; i &amp;lt; cs_in_table; ++i)
        {
            const uint8_t </em>offset = &amp;amp;cs_table_base[i * sizeof(LSDA_Call_Site)];
            LSDA_Call_Site cs(offset);
            if (cs.cs_lp)
            {
                uintptr_t func_start = _Unwind_GetRegionStart(context);
                _Unwind_SetIP(context, func_start + cs.cs_lp);
                break;
            }
        }
        return _URC_INSTALL_CONTEXT;
</pre>
<p>Try to run it, and watch a beautiful infinite loop. Can you guess what went wrong? The answer on the next article.</p>
<hr />
<h2>C++ exceptions under the hood 13: setting the context for a landing pad<a name="cexceptionsunderthehood13settingthecontextforalandingpad"></a></h2>
<p>Last time we finally wrote an almost working personality function. We can detect for each stack frame which landing pads are available and then tell _Unwind_ we want to run a specific landing pad. We hit a small issue, though: although we set the context for _Unwind_ to continue executing on the correct landing pad we didn&rsquo;t set the current exception on the register. This, in turn, means that the landing pad won&rsquo;t know which exception should be handling, so it will say &ldquo;I can&rsquo;t handle this&rdquo;. _Unwind_ will then say &ldquo;please try the next landing pad&rdquo; but our ABI is so simple that it has no idea how it should find another landing pad and just tries the same. Over and over again. We have probably invented the most contrived example for a while(true)!</p>
<p>Let&rsquo;s set the correct context for the landing pad and clean up a bit our ABI:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
namespace __cxxabiv1 {
    struct __class_type_info {
        virtual void foo() {}
    } ti;
}
#define EXCEPTION_BUFF_SIZE 255
char exception_buff[EXCEPTION_BUFF_SIZE];
extern &quot;C&quot; {
void<em> __cxa_allocate_exception(size_t thrown_size)
{
    printf(&quot;alloc ex %i\n&quot;, thrown_size);
    if (thrown_size &amp;gt; EXCEPTION_BUFF_SIZE) printf(&quot;Exception too big&quot;);
    return &amp;amp;exception_buff;
}
void __cxa_free_exception(void </em>thrown_exception);
#include &amp;lt;unwind.h&amp;gt;
typedef void (<em>unexpected_handler)(void);
typedef void (</em>terminate_handler)(void);
struct __cxa_exception {
    std::type_info *    exceptionType;
    void (<em>exceptionDestructor) (void </em>);
    unexpected_handler  unexpectedHandler;
    terminate_handler   terminateHandler;
    __cxa_exception *   nextException;
    int         handlerCount;
    int         handlerSwitchValue;
    const char *        actionRecord;
    const char *        languageSpecificData;
    void *          catchTemp;
    void *          adjustedPtr;
    _Unwind_Exception   unwindHeader;
};
void __cxa_throw(void<em> thrown_exception,
                 struct type_info </em>tinfo,
                 void (<em>dest)(void</em>))
{
    printf(&quot;__cxa_throw called\n&quot;);
    __cxa_exception <em>header = ((__cxa_exception </em>) thrown_exception - 1);
    _Unwind_RaiseException(&amp;amp;header-&amp;gt;unwindHeader);
    // __cxa_throw never returns
    printf(&quot;no one handled __cxa_throw, terminate!\n&quot;);
    exit(0);
}
void __cxa_begin_catch()
{
    printf(&quot;begin FTW\n&quot;);
}
void __cxa_end_catch()
{
    printf(&quot;end FTW\n&quot;);
}
/<strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><em>/
/</em><em>
 * The LSDA is a read only place in memory; we&amp;#x27;ll create a typedef for
 * this to avoid a const mess later on; LSDA_ptr refers to readonly and
 * &amp;amp;LSDA_ptr will be a non-const pointer to a const place in memory
 </em>/
typedef const uint8_t<em> LSDA_ptr;
struct LSDA_Header {
    /</em><em>
     * Read the LSDA table into a struct; advances the lsda pointer
     * as many bytes as read
     </em>/
    LSDA_Header(LSDA_ptr <em>lsda) {
        LSDA_ptr read_ptr = </em>lsda;
        // Copy the LSDA fields
        start_encoding = read_ptr[0];
        type_encoding = read_ptr[1];
        ttype = read_ptr[2];
        // Advance the lsda pointer
        <em>lsda = read_ptr + sizeof(LSDA_Header);
    }
    uint8_t start_encoding;
    uint8_t type_encoding;
    uint8_t ttype;
};
struct LSDA_CS_Header {
    // Same as other LSDA constructors
    LSDA_CS_Header(LSDA_ptr </em>lsda) {
        LSDA_ptr read_ptr = <em>lsda;
        encoding = read_ptr[0];
        length = read_ptr[1];
        </em>lsda = read_ptr + sizeof(LSDA_CS_Header);
    }
    uint8_t encoding;
    uint8_t length;
};
struct LSDA_CS {
    // Same as other LSDA constructors
    LSDA_CS(LSDA_ptr <em>lsda) {
        LSDA_ptr read_ptr = </em>lsda;
        start = read_ptr[0];
        len = read_ptr[1];
        lp = read_ptr[2];
        action = read_ptr[3];
        <em>lsda = read_ptr + sizeof(LSDA_CS);
    }
    // Note start, len and lp would be void</em>&amp;#x27;s, but they are actually relative
    // addresses: start and lp are relative to the start of the function, len
    // is relative to start
    // Offset into function from which we could handle a throw
    uint8_t start;
    // Length of the block that might throw
    uint8_t len;
    // Landing pad
    uint8_t lp;
    // Offset into action table + 1 (0 means no action)
    // Used to run destructors
    uint8_t action;
};
/<strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><em><strong>*</strong>/
_Unwind_Reason_Code __gxx_personality_v0 (
                             int version,
                             _Unwind_Action actions,
                             uint64_t exceptionClass,
                             _Unwind_Exception</em> unwind_exception,
                             _Unwind_Context<em> context)
{
    if (actions &amp;amp; _UA_SEARCH_PHASE)
    {
        printf(&quot;Personality function, lookup phase\n&quot;);
        return _URC_HANDLER_FOUND;
    } else if (actions &amp;amp; _UA_CLEANUP_PHASE) {
        printf(&quot;Personality function, cleanup\n&quot;);
        // Pointer to the beginning of the raw LSDA
        LSDA_ptr lsda = (uint8_t</em>)_Unwind_GetLanguageSpecificData(context);
        // Read LSDA headerfor the LSDA
        LSDA_Header header(&amp;amp;lsda);
        // Read the LSDA CS header
        LSDA_CS_Header cs_header(&amp;amp;lsda);
        // Calculate where the end of the LSDA CS table is
        const LSDA_ptr lsda_cs_table_end = lsda + cs_header.length;
        // Loop through each entry in the CS table
        while (lsda &amp;lt; lsda_cs_table_end)
        {
            LSDA_CS cs(&amp;amp;lsda);
            if (cs.lp)
            {
                int r0 = __builtin_eh_return_data_regno(0);
                int r1 = __builtin_eh_return_data_regno(1);
                _Unwind_SetGR(context, r0, (uintptr_t)(unwind_exception));
                // Note the following code hardcodes the exception type;
                // we&amp;#x27;ll fix that later on
                _Unwind_SetGR(context, r1, (uintptr_t)(1));
                uintptr_t func_start = _Unwind_GetRegionStart(context);
                _Unwind_SetIP(context, func_start + cs.lp);
                break;
            }
        }
        return _URC_INSTALL_CONTEXT;
    } else {
        printf(&quot;Personality function, error\n&quot;);
        return _URC_FATAL_PHASE1_ERROR;
    }
}
}
</pre>
<p>Note: For a more detailed description of the LSDA tables check <a href="/blog_md/youfoundadeadlink.mdexceptions.pdf">here</a> and for the full source code <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v06">check my github repo</a>.</p>
<p>Finally, it worked. You should see something like this if you run it:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">./app
alloc ex 1
__cxa_throw called
Personality function, lookup phase
Personality function, cleanup
begin FTW
Caught a Fake_Exception!
end FTW
try_but_dont_catch handled the exception
catchit handled the exception
</pre>
<p>Of course we are lying a bit to _Unwind_: we are saying here that we will handle every exception, no mater what. This turns our catch(Exception&amp;) into a catch(&hellip;), and all hell will break loose if the first function up in the call frame doesn&rsquo;t have a catch statement. But still, we reached the first milestone for a very simple ABI.</p>
<p>Can we now improve it and make it handle the correct exception on the correct frame? May be next time.</p>
<hr />
<h2>C++ exceptions under the hood 14: multiple landing pads &amp; the teachings of the guru<a name="cexceptionsunderthehood14multiplelandingpadstheteachingsoftheguru"></a></h2>
<p>After a lot of hard work, last time we finally got a working personality function capable of handling exceptions without help of libstdc++. It will indiscriminately handle all exceptions, but it does work. There is a big question we haven&rsquo;t answered yet: if we go back to the LSDA (language specific data area) we&rsquo;ll see something like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.local_lsda_call_site_table:
    .uleb128 .LEHB0-.LFB1
    .uleb128 .LEHE0-.LEHB0
    .uleb128 .L8-.LFB1
    .uleb128 0x1
    .uleb128 .LEHB1-.LFB1
    .uleb128 .LEHE1-.LEHB1
    .uleb128 0
    .uleb128 0
  .uleb128 .LEHB2-.LFB1
    .uleb128 .LEHE2-.LEHB2
    .uleb128 .L9-.LFB1
    .uleb128 0
.local_lsda_call_site_table_end:
</pre>
<p>There are 3 landing pads defined there, even though we wrote a single try/catch statement. What is going on there?</p>
<p>If you read carefully the last entry on this topic maybe you noticed I added some comments to the definition of struct LSDA_CS:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct LSDA_CS {
    // Note start, len and lp would be void*&amp;#x27;s, but they are actually relative
    // addresses: start and lp are relative to the start of the function, len
    // is relative to start
    // Offset into function from which we could handle a throw
    uint8_t start;
    // Length of the block that might throw
    uint8_t len;
    // Landing pad
    uint8_t lp;
    // Offset into action table + 1 (0 means no action)
    // Used to run destructors
    uint8_t action;
};
</pre>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v06">in my github repo</a>.</p>
<p>Something very interesting is going on here, but lets first analyze this struct field by field with the following example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void foo() {
    L0:
        try {
            do_something();
    L1:
        } catch (const Exception1&amp;amp; ex) {
            &hellip;
        } catch (const Exception2&amp;amp; ex) {
            &hellip;
        } catch (const ExceptionN&amp;amp; ex) {
            &hellip;
        } catch (&hellip;) {
        }
    L2:
}
</pre>
<ul>
<li>lp: the offset from the start of the function where the landing pad starts. The value of lp for the following example would be L1 - addr_of(foo)</li>
<li>action: an offset into an action table. This is used to run the cleanup actions while unwinding the stack. We haven&rsquo;t reached this point yet, we can ignore it for now.</li>
<li>start: the offset from the start of the function where the try block begins: in the example this would be L0 - addr_of(foo)</li>
<li>len: the length of the try block. On the example this would be L1 - L0</li>
</ul>
<p>The interesting fields now are start and len: in a function with multiple try/catch blocks we can know whether we should handle an exception by checking if the instruction pointer for the current frame is between start and start + len.</p>
<p>That solves the mystery of how a function with multiple try/catch blocks can handle an exception but we still have another question: why are there three call sites when we only specified a single landing pad? The other three are places where an exception might be thrown so they get added as a possible place for cleanup actions or landing pads. If we learned anything from GOTW it should be that exceptions can be thrown in the places we least expect. There is an entry in the call site table for our throw because it&rsquo;s a block that might throw; the compiler also detected another three.</p>
<p>Now that we know what the start and len fields do, let&rsquo;s change our personality function so the correct landing pad can handle the exception being thrown. Go ahead. My implementation for the next time.</p>
<hr />
<h2>C++ exceptions under the hood 15: finding the right landing pad<a name="cexceptionsunderthehood15findingtherightlandingpad"></a></h2>
<p>This is now the 15th installment in what&rsquo;s becoming the longest series I&rsquo;ve written for this blog; we have so far learned how exceptions are thrown and we have written a personality function capable of, with some sort of reflexion, detecting where the catch-blocks are (landing pads, in exception speak). In the last article we wrote a personality function that can handle exceptions, but it does so only with the first landing pad of the first call frame in the stack. Let&rsquo;s improve that a little bit, let&rsquo;s make our personality function capable of choosing the right landing pad in a function with multiple landing pads.</p>
<p>In a TDD fashion we can first build a test for our ABI. Let&rsquo;s modify our test program, throw.cpp, to have two try/catch blocks:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;stdio.h&amp;gt;
#include &quot;throw.h&quot;
struct Fake_Exception {};
void raise() {
    throw Exception();
}
void try_but_dont_catch() {
    try {
        printf(&quot;Running a try which will never throw.\n&quot;);
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Exception caught&hellip; with the wrong catch!\n&quot;);
    }
    try {
        raise();
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Caught a Fake_Exception!\n&quot;);
    }
    printf(&quot;try_but_dont_catch handled the exception\n&quot;);
}
void catchit() {
    try {
        try_but_dont_catch();
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Caught a Fake_Exception!\n&quot;);
    } catch(Exception&amp;amp;) {
        printf(&quot;Caught an Exception!\n&quot;);
    }
    printf(&quot;catchit handled the exception\n&quot;);
}
extern &quot;C&quot; {
    void seppuku() {
        catchit();
    }
}
</pre>
<p>Before you test it, try to think about what will happen upon running this test. Focus on the try_but_dont_catch function: the first try/catch block will not throw, then the second block will throw. Since our ABI is quite dumb the first block will handle the second block&rsquo;s exception. What will happen after the first block has finished handling the exception? The execution will resume from where the catch/try ends, thus entering again on the second try/catch block. Infinite loop! We have reinvented yet again a very complicated while(true).</p>
<p>Let&rsquo;s use our knowledge of the start/length fields in the call site table (LSDA) to properly choose our landing pad. For this we will need to know what the instruction pointer was when the exception was thrown, and we can do this with an _Unwind_ function we already know: _Unwind_GetIP. To understand what _Unwind_GetIP will return let&rsquo;s see an example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void f1() {}
void f2() { throw 1; }
void f3() {}
void foo() {
L1:
    try{ f1(); } catch(&hellip;) {}
L2:
    try{ f2(); } catch(&hellip;) {}
L3:
    try{ f3(); } catch(&hellip;) {}
}
</pre>
<p>In this case our personality function would be called for the catch block for f2 and the stack would be like this:</p>
<pre style="display: inline-block; border: 1px solid red;">+------------------------------+
|   IP: f2  stack frame: f2    |
+------------------------------+
|   IP: L3  stack frame: foo   |
+------------------------------+
</pre>
<p>Note that IP will be at L3 but the exception will be thrown in L2; this is because the IP will point to the next instruction to execute. This also means we need to substract one if we need to find the IP where an exception was thrown, otherwise the result from _Unwind_GetIP would not be in the range of our landing pad. Back to our personality function:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">_Unwind_Reason_Code __gxx_personality_v0 (
                             int version,
                             _Unwind_Action actions,
                             uint64_t exceptionClass,
                             _Unwind_Exception<em> unwind_exception,
                             _Unwind_Context</em> context)
{
    if (actions &amp;amp; _UA_SEARCH_PHASE)
    {
        printf(&quot;Personality function, lookup phase\n&quot;);
        return _URC_HANDLER_FOUND;
    } else if (actions &amp;amp; _UA_CLEANUP_PHASE) {
        printf(&quot;Personality function, cleanup\n&quot;);
        // Calculate what the instruction pointer was just before the
        // exception was thrown for this stack frame
        uintptr_t throw_ip = _Unwind_GetIP(context) - 1;
        // Pointer to the beginning of the raw LSDA
        LSDA_ptr lsda = (uint8_t*)_Unwind_GetLanguageSpecificData(context);
        // Read LSDA headerfor the LSDA
        LSDA_Header header(&amp;amp;lsda);
        // Read the LSDA CS header
        LSDA_CS_Header cs_header(&amp;amp;lsda);
        // Calculate where the end of the LSDA CS table is
        const LSDA_ptr lsda_cs_table_end = lsda + cs_header.length;
        // Loop through each entry in the CS table
        while (lsda &amp;lt; lsda_cs_table_end)
        {
            LSDA_CS cs(&amp;amp;lsda);
            // If there&amp;#x27;s no LP we can&amp;#x27;t handle this exception; move on
            if (not cs.lp) continue;
            uintptr_t func_start = _Unwind_GetRegionStart(context);
            // Calculate the range of the instruction pointer valid for this
            // landing pad; if this LP can handle the current exception then
            // the IP for this stack frame must be in this range
            uintptr_t try_start = func_start + cs.start;
            uintptr_t try_end = func_start + cs.start + cs.len;
            // Check if this is the correct LP for the current try block
            if (throw_ip &amp;lt; try_start) continue;
            if (throw_ip &amp;gt; try_end) continue;
            // We found a landing pad for this exception; resume execution
            int r0 = __builtin_eh_return_data_regno(0);
            int r1 = __builtin_eh_return_data_regno(1);
            _Unwind_SetGR(context, r0, (uintptr_t)(unwind_exception));
            // Note the following code hardcodes the exception type;
            // we&amp;#x27;ll fix that later on
            _Unwind_SetGR(context, r1, (uintptr_t)(1));
            _Unwind_SetIP(context, func_start + cs.lp);
            break;
        }
        return _URC_INSTALL_CONTEXT;
    } else {
        printf(&quot;Personality function, error\n&quot;);
        return _URC_FATAL_PHASE1_ERROR;
    }
}
</pre>
<p>As usual: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v07">in my github repo</a>.</p>
<p>Try the example again and voila, no more infinite loop! That was a simple change and we can now choose the correct landing pad. Next time we&rsquo;ll try to make our personality function also pick the correct stack frame instead of choosing the first one.</p>
<hr />
<h2>C++ exceptions under the hood 16: finding the right catch in a landing pad<a name="cexceptionsunderthehood16findingtherightcatchinalandingpad"></a></h2>
<p>16th chapter on our quest to implement a mini-ABI capable of handling exceptions; last time we implemented our personality function so it would be able to handle functions with more than one landing pad. We are now trying to make it recognize whether a certain landing pad can handle a specific exception, so we can use the exception specification on the catch statement.</p>
<p>Of course, to know whether a landing pad can handle a throw is a difficult task. Would you expect anything else? The biggest problems to overcome right now will be:</p>
<ul>
<li>First and foremost: how can we find the accepted types for a catch block?</li>
<li>Assuming we can find the types for a catch, how can we handle a catch(&hellip;)?</li>
<li>For a landing pad with multiple catch statements, how can we know all possibly catch types?</li>
<li>Take the following example. Not only we&rsquo;ll have to check whether the landing pad accepts the current exception, we&rsquo;ll have to check if it accepts any of the current exception&rsquo;s parents!</li>
</ul>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">
struct Base {};
struct Child : public Base {};
void foo() { throw Child; }
void bar()
{
    try { foo(); }
    catch(const Base&amp;amp;){ &hellip; }
}
</pre>
<p>To make our work a bit easier let&rsquo;s say for now we work only with landing pads that have a single catch and no inheritance exists on our program. Still, how do we find out the accepted types for a landing pad?</p>
<p>Turns there is a place in .gcc_except_table we haven&rsquo;t analyzed yet: the action table. Let&rsquo;s dissasemble our throw.cpp object and see what&rsquo;s in there, right after the call site table is finished, for our &ldquo;try but don&rsquo;t catch&rdquo; function:</p>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v07">in my github repo</a>.</p>
<pre style="display: inline-block; border: 1px solid red;">.LLSDACSE1:
    .byte   0x1
    .byte   0
    .align 4
    .long   _ZTI14Fake_Exception
.LLSDATT1:
</pre>
<p>Doesn&rsquo;t look like much, but there&rsquo;s a promising pointer (both a proverbial and a real pointer) to something that has our exception&rsquo;s name. Let&rsquo;s go to the definition of _ZTI14Fake_Exception:</p>
<pre style="display: inline-block; border: 1px solid red;">_ZTI14Fake_Exception:
    .long   _ZTVN10__cxxabiv117__class_type_infoE+8
    .long   _ZTS14Fake_Exception
    .weak   _ZTS9Exception
    .section    .rodata._ZTS9Exception,&quot;aG&quot;,@progbits,_ZTS9Exception,comdat
    .type   _ZTS9Exception, @object
    .size   _ZTS9Exception, 11
</pre>
<p>And we reached something very interesting. Can you recognize it? This is the std::type_info for struct Fake_Exception!</p>
<p>Now we know there is indeed a way to get a pointer to some kind of reflexion information for our exception. Can we programmatically find it? We&rsquo;ll see next time.</p>
<hr />
<h2>C++ exceptions under the hood 17: reflecting on an exception type and reading .gcc_except_table<a name="cexceptionsunderthehood17reflectingonanexceptiontypeandreading.gcc_except_table"></a></h2>
<p>By now we know that when an exception is thrown we can get a lot of reflexion information by reading the local data storage area AKA .gcc_except_table; reading this table we have been able to implement a personality function capable of deciding which landing pad to run when an exception is thrown. We also know how to read the action table part of the LSDA, so we should be able to modify our personality function to pick the correct catch statement inside a landing pad with multiple catches.</p>
<p>We left our ABI implementation last time, and dedicated some time to analyze the assembly for .gcc_except_table to discover how can we find the types a catch can handle. We found that indeed there is a part of this table that holds a list of types where this information can be found. Let&rsquo;s try to read it on the cleanup phase, but first let&rsquo;s remember the definition for our LSDA header:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct LSDA_Header {
    uint8_t start_encoding;
    uint8_t type_encoding;
    // This is the offset, from the end of the header, to the types table
    uint8_t type_table_offset;
};
</pre>
<p>That last field is new (for us): it&rsquo;s giving us an offset into table of types. Let&rsquo;s also remember the definition of each call site:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct LSDA_CS {
    // Offset into function from which we could handle a throw
    uint8_t start;
    // Length of the block that might throw
    uint8_t len;
    // Landing pad
    uint8_t lp;
    // Offset into action table + 1 (0 means no action)
    uint8_t action;
};
</pre>
<p>Check that last field, &ldquo;action&rdquo;. That gives us an offset into the action table. That means we can find the action for a specific CS. The trick here is that for landing pads where a catch exists, the action will hold an offset for the types table; we can then use the offset into the types table pointer, which we can get from the header. Quite a mouthful: let&rsquo;s better talk code:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">// Pointer to the beginning of the raw LSDA
LSDA_ptr lsda = (uint8_t<em>)_Unwind_GetLanguageSpecificData(context);
// Read LSDA headerfor the LSDA
LSDA_Header header(&amp;amp;lsda);
const LSDA_ptr types_table_start = lsda + header.type_table_offset;
// Read the LSDA CS header
LSDA_CS_Header cs_header(&amp;amp;lsda);
// Calculate where the end of the LSDA CS table is
const LSDA_ptr lsda_cs_table_end = lsda + cs_header.length;
// Get the start of action tables
const LSDA_ptr action_tbl_start = lsda_cs_table_end;
// Get the first call site
LSDA_CS cs(&amp;amp;lsda);
// cs.action is the offset + 1; that way cs.action == 0
// means there is no associated entry in the action table
const size_t action_offset = cs.action - 1;
const LSDA_ptr action = action_tbl_start + action_offset;
// For a landing pad with a catch the action table will
// hold an index to a list of types
int type_index = action[0];
// types_table_start actually points to the end of the table, so
// we need to invert the type_index. There we&amp;#x27;ll find a ptr to
// the std::type_info for the specification in our catch
const void</em> catch_type_info = types_table_start[ -1 * type_index ];
const std::type_info <em>catch_ti = (const std::type_info </em>) catch_type_info;
// If everything went OK, this should print something like Fake_Exception
printf(&quot;%s\n&quot;, catch_ti-&amp;gt;name());
</pre>
<p>The code looks complicated because there are several layers of indirection before actually reaching the struct type_info, but it&rsquo;s not really doing anything complicated: it only reads the .gcc_except_table we found on the disassembly.</p>
<p>Printing the name of the type is already a big step in the right direction. Also, our personality function is getting a bit messy. Most of the complexity of reading the LSDA can be hidden under the rug for almost no cost at all. You can check my <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v08">implementation here</a>
Next time we&rsquo;ll see if we can match our newly found type to our original exception.</p>
<hr />
<h2>C++ exceptions under the hood 18: getting the right stack frame<a name="cexceptionsunderthehood18gettingtherightstackframe"></a></h2>
<p>Our latest personality function knows whether it can handle an exception or not (assuming there is only one catch statement per try block and assuming no inheritance is used) but to make this knowledge useful, we have first to check if the exception we can handle matches the exception being thrown. Let&rsquo;s try to do this.</p>
<p>Of course, we need first to know the exception type. To do this we need to save the exception type when <strong>__cxa_throw</strong> is called (this is the chance the ABI gives us to set all our custom data):</p>
<p>Note: You can download the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v09">in my github repo</a>.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void __cxa_throw(void<em> thrown_exception,
                 std::type_info </em>tinfo,
                 void (<em>dest)(void</em>))
{
    __cxa_exception <em>header = ((__cxa_exception </em>) thrown_exception - 1);
    // We need to save the type info in the exception header <em>Unwind</em> will
    // receive, otherwise we won&amp;#x27;t be able to know it when unwinding
    header-&amp;gt;exceptionType = tinfo;
    _Unwind_RaiseException(&amp;amp;header-&amp;gt;unwindHeader);
}
</pre>
<p>And now we can read the exception type in our personality function and easily check if the exception types match (the exception names are C++ strings, so doing a == is enough to check this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">// Get the type of the exception we can handle
const void<em> catch_type_info = lsda.types_table_start[ -1 * type_index ];
const std::type_info </em>catch_ti = (const std::type_info <em>) catch_type_info;
// Get the type of the original exception being thrown
__cxa_exception</em> exception_header = (__cxa_exception<em>)(unwind_exception+1) - 1;
std::type_info </em>org_ex_type = exception_header-&amp;gt;exceptionType;
printf(&quot;%s thrown, catch handles %s\n&quot;,
            org_ex_type-&amp;gt;name(),
            catch_ti-&amp;gt;name());
// Check if the exception being thrown is of the same type
// than the exception we can handle
if (org_ex_type-&amp;gt;name() != catch_ti-&amp;gt;name())
    continue;
</pre>
<p>Check <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v09">here</a> for the full source with the new changes.</p>
<p>Of course there would be a problem if we add that (can you see it?). If the exception is thrown in two phases and we said in the first one we would handle it, then we can&rsquo;t say on the second one we don&rsquo;t want it anymore. I don&rsquo;t know if _Unwind_ handles this case according to any documentation but this is most likely calling upon undefined behavior, so just saying we&rsquo;ll handle everything is no longer enough.</p>
<p>Since we gave our personality function the ability to know if the landing pad can handle the exception being thrown we have been lying to _Unwind_ about which exceptions we can handle; even though we said we handle all of them on <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v09">our ABI 9</a>, the truth is that we didn&rsquo;t know whether we would be able to handle it. That&rsquo;s easy to change, we can do something like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;"><em>Unwind_Reason_Code __gxx_personality_v0 (&hellip;)
{
    printf(&quot;Personality function, searching for handler\n&quot;);
    // &hellip;
    foreach (call site entry in lsda)
    {
        if (call site entry.not_good()) continue;
        // We found a landing pad for this exception; resume execution
        // If we are on search phase, tell _Unwind</em> we can handle this one
        if (actions &amp;amp; _UA_SEARCH_PHASE) return _URC_HANDLER_FOUND;
        // If we are not on search phase then we are on _UA_CLEANUP_PHASE
        /<em> set everything so the landing pad can run </em>/
        return _URC_INSTALL_CONTEXT;
    }
    return _URC_CONTINUE_UNWIND;
}
</pre>
<p>As usual, check the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v10">in my github repo</a>.</p>
<p>So, what would we get if we run the personality function with this change? Fail, that&rsquo;s what we&rsquo;d get! Remember our throwing functions? This one should catch our exception:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void catchit() {
    try {
        try_but_dont_catch();
    } catch(Fake_Exception&amp;amp;) {
        printf(&quot;Caught a Fake_Exception!\n&quot;);
    } catch(Exception&amp;amp;) {
        printf(&quot;Caught an Exception!\n&quot;);
    }
    printf(&quot;catchit handled the exception\n&quot;);
}
</pre>
<p>Unfortunately, our personality function only checks for the first type the landing pad can handle. If we delete the Fake_Exception catch block and try it again, though, we&rsquo;d get a different story: finally, success! Our personality function can now select the correct catch in the correct frame, provided there&rsquo;s no try block with multiple catches.</p>
<p>Next time we&rsquo;ll be further improving this.</p>
<hr />
<h2>C++ exceptions under the hood 19: getting the right catch in a landing pad<a name="cexceptionsunderthehood19gettingtherightcatchinalandingpad"></a></h2>
<p>19th entry about C++ exception handling: we have written a personality function that can so far, by reading the LSDA, choose the right landing pad on the right stack frame to handle a thrown exception, but it was having some difficulties finding the right catch inside a landing pad. To finally get a decently working personality function we&rsquo;ll need to check all the types an exception can handle by going through all the actions table in the .gcc_except_table.</p>
<p>Remember the action table? Let&rsquo;s check it again but this time for a try with multiple catch blocks.</p>
<pre style="display: inline-block; border: 1px solid red;"># Call site table
.LLSDACSB2:
    # Call site 1
    .uleb128 ip_range_start
    .uleb128 ip_range_len
    .uleb128 landing_pad_ip
    .uleb128 (action_offset+1) =&gt; 0x3
    # Rest of call site table
# Action table start
.LLSDACSE2:
    # Action 1
    .byte   0x2
    .byte   0
    # Action 2
    .byte   0x1
    .byte   0x7d
    .align 4
    .long   _ZTI9Exception
    .long   _ZTI14Fake_Exception
.LLSDATT2:
# Types table start
</pre>
<p>If we intend to read the exceptions supported by the landing pad 1 in the example above (that LSDA is for the catchit function, by the way) we need to do something like this:</p>
<ul>
<li>Get the action offset from the call site table, 2: remember you&rsquo;ll actually read the offset plus 1, so 0 means no action.</li>
<li>Go to action offset 2, get type index 1. The types table is indexed in reverse order (ie we have a pointer to its end and we need to access each element by using -1 * index).</li>
<li>Go to types_table[-1]; you&rsquo;ll get a pointer to the type_info for Fake_Exception</li>
<li>Fake_Exception is not the current exception being thrown; get the next action offset for our current action (0x7d)</li>
<li>Reading 0x7d in uleb128 will actually yield -3; from the position where we read the offset move back 3 bytes to find the next action</li>
<li>Read type index 2</li>
<li>Get the type_info for Exception this time; it matches the current exception being thrown, so we can install the landing pad!</li>
</ul>
<p>It sounds complicated because there&rsquo;s, again, a lot of indirection for each step but you can check the full sourcecode for this project <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v11">in my github repo</a>.</p>
<p>In the link above you will also see a bonus: a change to the personality function to correctly detect and use catch(&hellip;) blocks. That&rsquo;s an easy change once the personality functions knows how to read the types table: a type with a null pointer (ie a position in the table that instead of a valid pointer to an std::type_info holds null) represents a catch all block. This has an interesting side effect: a catch(T) will be able to handle only native (ie coming from C++) exceptions, whereas a catch(&hellip;) would catch also exceptions not thrown from within C++.</p>
<p>We finally know how exceptions are thrown, how the stack is unwinded, how a personality function selects the correct stack frame to handle an exception and how the right catch inside a landing pad is selected, but we still have on more problem to solve: running destructors. We&rsquo;ll change our personality function to support RAII objects next time.</p>
<hr />
<h2>C++ exceptions under the hood 20: running destructors while unwinding<a name="cexceptionsunderthehood20runningdestructorswhileunwinding"></a></h2>
<p>The <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v11">mini ABI version 11</a> we have written last time was able to handle pretty much all the basics to handle an exception: we have an (almost working) ABI capable of throwing and catching exceptions, but it is still unable to properly run destructors. That&rsquo;s quite important if we want to write exception safe code. With what we know about .gcc_except_table running destructors is a piece of cake, we only need to see a bit of assembly:</p>
<pre style="display: inline-block; border: 1px solid red;"># Call site table
.LLSDACSB2:
    # Call site 1
    .uleb128 ip_range_start
    .uleb128 ip_range_len
    .uleb128 landing_pad_ip
    .uleb128 (action_offset+1) =&gt; 0x3
    # Rest of call site table
# Action table start
.LLSDACSE2:
    # Action 1
    .byte   0
    .byte   0
    # Action 2
    .byte   0x1
    .byte   0x7d
    .align 4
    .long   _ZTI14Fake_Exception
.LLSDATT2:
# Types table start
</pre>
<p>On a regular landing pad, when an action has a type index greater than 0 it means we&rsquo;re seeing an index to a type tables, and we can use that to know which types the catch can handle; for a type index with a value of 0 it means we are instead seeing a cleanup block and we should run it anyway. Although the landing pad can&rsquo;t handle the exception it will still be able to perform the cleanup that&rsquo;s supposed to happen while unwinding. Of course the landing pad will call _Unwind_Resume when the cleanup is done and that will continue the regular stack unwinding process.</p>
<p>I&rsquo;ve uploaded this <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v12">latest and last version to my github repo</a>, but there are some bad news: remember how we cheated by saying that a uleb128 == char? As soon as we start adding blocks to run destructors the .gcc_except_table starts to get quite big (where &ldquo;big&rdquo; means we have offsets over 127 bytes long) and that assumption no longer holds.</p>
<p>For the next version of this ABI we would have to rewrite our LSDA reading functions to read proper uleb128 code. Not a major change, but at this point we wouldn&rsquo;t gain much, we have already achieved our goal: a working minimal ABI capable of handling exceptions without the help of libcxxabi.</p>
<p>There are parts we haven&rsquo;t covered, like handling non-native exceptions, catching derived types or interoperability between compilers and linkers. Maybe some other time, in this rather long series of articles we already learned quite a bit about low level exception handling in C++.</p>
<hr />
<h2>C++ exceptions under the hood 21: a summary and some final thoughts<a name="cexceptionsunderthehood21asummaryandsomefinalthoughts"></a></h2>
<p>After writing twenty some articles about C++ low level exception handling, it&rsquo;s time for a recap and some final thoughts. What did we learn, how is an exception thrown and how is it caught?</p>
<p>Leaving aside the ugly details of reading the .gcc_except_table, which were probably the biggest part of these articles, we could summarize the whole process like this:</p>
<ol>
<li>The C++ compiler actually does rather little to handle an exception, most of the magic actually happens in libstdc++.</li>
<li>There are a few things the compiler does, though. Namely:<ul>
<li>It creates the CFI information to unwind the stack.</li>
<li>It creates something called .gcc_except_table with information about landing pads (try/catch blocks). Kind of like reflexion info.</li>
<li>When we write a throw statement, the compiler will translate it into a pair of calls into libstdc++ functions that allocate the exception and then start the stack unwinding process by calling libstdc.</li>
</ul>
</li>
<li>When an exception is thrown at runtime __cxa_throw will be called, which will delegate the stack unwinding to libstdc.</li>
<li>As the unwinder goes through the stack it will call a special function provided by libstdc++ (called personality routine) that checks for each function in the stack which exceptions can be caught.</li>
<li>If no matching catch is found for the exception, std::terminate is called.</li>
<li>If a matching catch is found, the unwinder now starts again on the top of the stack.</li>
<li>As the unwinder goes through the stack a second time it will ask the personality routine to perform a cleanup for this method.</li>
<li>The personality routine will check the .gcc_except_table for the current method. If there are any cleanup actions to be run, it will &ldquo;jump&rdquo; into the current stack frame and run the cleanup code. This will run the destructor for each object allocated at the current scope.</li>
<li>Once the unwinder reaches the frame in the stack that can handle the exception it will jump into the proper catch statement.</li>
<li>Upon finishing the execution of the catch statement, a cleanup function will be called to release the memory held for the exception.</li>
</ol>
<p>Having learned how exceptions work we are now in a position to better answer why it&rsquo;s hard to write exception safe code.</p>
<p>Exceptions, while conceptually clean, are pretty much &ldquo;spooky action at a distance&rdquo;. Throwing and catching an exception involves a certain degree of reflexion (in the sense that a program must analyze itself) which is not common for C++ applications.</p>
<p>Even if we talk about higher level languages, throwing an exception means we cannot rely on our understanding of how a normal program execution flow should work anymore: we are used to a pretty much linear execution flow with some conditional operators branching or calling other functions. With an exception, this no longer holds true: an entity which is not the code of our application is in control of the execution, and it goes around the program executing certain blocks of code here and there without following any of the normal rules. The instruction pointer gets changed by each landing pad, the stack is unwinded in ways we can&rsquo;t control and, ultimately, a lot of magic happens under the hood.</p>
<p>To summarize it even more: exceptions are hard simply because they break the natural flow of a program as we understand it. This does not mean they are intrinsically bad as properly used exceptions can surely lead to cleaner code, but they should always be used with care.</p>
<hr />
<h2>C++ exceptions under the hood appendix I: the true cost of an exception<a name="cexceptionsunderthehoodappendixithetruecostofanexception"></a></h2>
<p>Remember a long way back, when the series on exception handling was just started, that I mentioned these articles would only apply for gcc/x86? There is a reason for that since not all compilers implement exception handling the same way. In particular, there are two major ways of doing it:</p>
<ul>
<li>With a lookup table and some metadata, like the Itanium ABI specifies; this is what we talked about.</li>
<li>Sj/Lj (ARM): Registering exception handling information upon entering or exiting a method.</li>
</ul>
<p>The way gcc (and many other compilers) implement this ABI on x86 is by using metadata (the .gcc_except_table and the CFI). Although it&rsquo;s rather difficult to parse, and it might take a long time to parse this on runtime when an exception is thrown, it has a great upside: if no exceptions are thrown then there&rsquo;s no setup cost to be paid. This is called &ldquo;Zero-cost exception handling&rdquo; because a normal execution, where no exceptions are thrown, no penalty is payed. The performance is exactly the same we would have as if we had specified nothrow. That&rsquo;s right, leaving code locality &amp; caching issues aside, using exceptions or not has no performance penalty unless an exception is actually thrown. This is a great advantage and it goes in line with C++ philosophy of having no-cost for non used features.</p>
<p>When using the noexcept specification while declaring a method (or an empty throw specifier, pre C++11) in the setup used for these articles the compiler would omit the creation of the .gcc_except_table. This will make the code more compact and it will improve the cache usage, but it&rsquo;s very unlikely that will have a noticeable impact on the performance of the application.</p>
<p>If we talk about ARM, Sj/Lj seems to be the default option (I&rsquo;m sure there&rsquo;s a good reason for that but I don&rsquo;t have enough experience with ARM to know it). This exception handling method is based on registering exception handling information upon entering or exiting a method which either uses exceptions or requires a cleanup if an exception is thrown. This will result in a quicker exception handling, but the setup cost is payed whether an exception is thrown or not.</p>
<p>If you&rsquo;re interested on reading more about sjlj and zero cost exception handling <a href="http://llvm.org/docs/ExceptionHandling.html">LLVM has great documentation</a>.</p>
<hr />
<h2>C++ exceptions under the hood appendix II: metaclasses and RTTI on C++<a name="cexceptionsunderthehoodappendixiimetaclassesandrttionc"></a></h2>
<p>A long time ago, when we where just starting to write our mini ABI to handle exceptions without libstdc++&rsquo;s help, we had to add an empty class to appease the linker:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">namespace __cxxabiv1 {
    struct __class_type_info {
        virtual void foo() {}
    } ti;
}
</pre>
<p>I mentioned this class is used to check whether a catch can handle a subtype of the exception thrown, but what does that exactly mean? Let&rsquo;s change a bit our throwing functions to see what happens when we start dealing with inheritance. You may want to check <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v12">the source code for these examples.</a></p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct Derived_Exception : public Exception {};
void raise() {
    throw Derived_Exception();
}
void catchit() {
    try {
        raise();
    } catch(Exception&amp;amp;) {
        printf(&quot;Caught an Exception!\n&quot;);
    } catch(Derived_Exception&amp;amp;) {
        printf(&quot;Caught a Derived_Exception!\n&quot;);
    }
    printf(&quot;catchit handled the exception\n&quot;);
}
</pre>
<p>What should happen in this example is crystal clear: it should print &ldquo;Caught an Exception&rdquo;, because that catch block should be able to handle both types, Exception and Derived_Exception. Not only that, if we compile throw.cpp we&rsquo;ll get a warning to let us know that the second catch is dead code:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">throw.cpp: In function void catchit():
throw.cpp:15:7: warning: exception of type Derived_Exception will be caught [enabled by default]
throw.cpp:13:7: warning:    by earlier handler for Exception [enabled by default]
</pre>
<p>Luckily a warning won&rsquo;t stop compilation; we can continue and try to link the resulting .o; we&rsquo;ll find a linker error:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">throw.o:(.rodata._ZTI17Derived_Exception[typeinfo for Derived_Exception]+0x0): undefined reference to `vtable for __cxxabiv1::__si_class_type_info&amp;#x27;
</pre>
<p>And again we start seeing __type_info errors. If we create a fake __si_class_type_info to workaround this problem we we&rsquo;ll finally see our ABI breaks down when dealing with inheritance, in a rather funny way: the compiler will warn us about dead code and then we see that same code being executed by our ABI!</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">g++ -c -o throw.o -O0 -ggdb throw.cpp
throw.cpp: In function void catchit():
throw.cpp:15:7: warning: exception of type Derived_Exception will be caught [enabled by default]
throw.cpp:13:7: warning:    by earlier handler for Exception [enabled by default]
gcc main.o throw.o mycppabi.o -O0 -ggdb -o app
./app
begin FTW
Caught a Derived_Exception!
end FTW
catchit handled the exception
</pre>
<p>Clearly there&rsquo;s something wrong with our ABI, and it&rsquo;s very easy to trace this problem back to the definition of &ldquo;can_handle&rdquo;, the part of the code that checks whether an exception can by caught by a catch block:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">bool can_handle(const std::type_info <em>thrown_exception,
                const std::type_info </em>catch_type)
{
    // If the catch has no type specifier we&amp;#x27;re dealing with a catch(&hellip;)
    // and we can handle this exception regardless of what it is
    if (not catch_type) return true;
    // Naive type comparisson: only check if the type name is the same
    // This won&amp;#x27;t work with any kind of inheritance
    if (thrown_exception-&amp;gt;name() == catch_type-&amp;gt;name())
        return true;
    // If types don&amp;#x27;t match just don&amp;#x27;t handle the exception
    return false;
}
</pre>
<p>Our ABI gets the std::type_info for the exception being thrown and for the type which can be handled, and then compares if the names for these types is the same. This is fine as long as no inheritance is involved, but in the example above we already found a case where an exception should be handled even though a name is not shared.</p>
<p>The same problem will arise when trying to catch a pointer to an exception: the names won&rsquo;t match. Even more interesting, if you try and link throw.cpp but change the catch to receive a pointer instead, you&rsquo;ll get a new linker error. If you fix it you should end up with something like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">namespace __cxxabiv1 {
    struct __class_type_info    { virtual void foo() {} } ti;
    struct __si_class_type_info { virtual void foo() {} } si;
    struct __pointer_type_info  { virtual void foo() {} } ptr;
}
</pre>
<p>A very interesting pattern is starting to emerge: there is a different *_type_info for each possible catch type used. In fact the compiler will generate a different structure for each throw style. For example, for these throws:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">throw new Exception;
throw Exception;
</pre>
<p>the compiler would generate something like:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">__cxa_throw(_Struct_Type_Info__Ptr__Exception);
__cxa_throw(_Struct_Type_Info__Class__Exception);
</pre>
<p>In fact, even for this simple example, the inheritance web (not tree, web) is quite complex (note that I&rsquo;m kind of inventing the mangling here, it&rsquo;s not what gcc uses):</p>
<p><img alt="" src="/blog_img/type_info_inheritance.png" />
All these classes are generated by the compiler to specify precisely which type is being thrown, and how. For example, if an exception of type &ldquo;Ptr__Type_Info__Derived_Exception&rdquo; is thrown then a catch can handle it if:</p>
<p>The catch type equals the thrown type exactly (this is the only check our ABI does).If the catch type is a pointer (ie inherits from cxxabi::ponter_type_info), and said pointer can be casted to the exception type.If the thrown type is a derived type, then we need to check if the catch type is a parent type</p>
<p>And this list is still missing lots of possibilities, but for the full list is better to check a real C++ ABI. <a href="http://libcxxabi.llvm.org/">LLVM</a> has very clear and easy to understand ABI, you can check these details in the file &ldquo;private_typeinfo.cpp&rdquo;. If you check LLVM&rsquo;s implementation of run time type information, you&rsquo;ll soon realize why we didn&rsquo;t implement this on our ABI: the amount of rules to determine whether two types are the same or not is incredibly complex.</p>
<hr />
<h3>C++ exceptions under the hood appendix III: RTTI and exceptions orthogonality<a name="cexceptionsunderthehoodappendixiiirttiandexceptionsorthogonality"></a></h3>
<p>Exception handling on C++ requires a lot of reflexion. I don&rsquo;t mean the programmer should be reflecting on exception handling (though that&rsquo;s probably not a bad idea), I mean that a piece of C++ code should be able to understand things about itself. This looks a lot like run-time type information, RTTI. Are they the same? If they are, does exception handling work without RTTI?</p>
<p>We might be able to get a clue about the difference between RTTI and exception handling by using -fno-rtti on gcc when compiling our ABI project. Let&rsquo;s use the <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/blob/master/abi_v12/throw.cpp">throw.cpp</a> file:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">g++ -fno-rtti -S throw.cpp -o throw.nortti.s
g++ -S throw.cpp -o throw.s
diff throw.s throw.nortti.s
</pre>
<p>If you try that yourself you should see there&rsquo;s no difference between the RTTI and the No-RTTI version. Can we conclude then that gcc&rsquo;s exception handling is done with a mechanism different to RTTI? Not yet, let&rsquo;s see what happens if we try to use RTTI ourselves:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void raise() {
    Exception ex;
    typeid(ex);
    throw Exception();
}
</pre>
<p>If you try and compile that, gcc will complain: you can&rsquo;t use typeid with -fno-rtti specified. Which makes sense. Let&rsquo;s see what typeid does with a simple test:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;typeinfo&amp;gt;
class Bar {};
const std::type_info&amp;amp; foo()
{
        Bar bar;
            return typeid(bar);
}
</pre>
<p>If we compile this with &ldquo;g++ -O0 -S&rdquo;, you will see foo compiled into something like this:</p>
<pre style="display: inline-block; border: 1px solid red;">_Z3foov:
.LFB19:
    # Prologue stuff&hellip;
    subl    $16, %esp
    # Bar bar
    movl    $_ZTI3Bar, %eax
    # typeid(bar)
    leave
    # Epilogue stuff&hellip;
_ZTS3Bar:
    # Definition for _ZTS3Bar&hellip;
_ZTI3Bar:
    .long   _ZTVN10__cxxabiv117__class_type_infoE+8
    .long   _ZTS3Bar
    .ident  &quot;GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3&quot;
    .section    .note.GNU-stack,&quot;&quot;,@progbits
</pre>
<p>Does that look familiar? If it doesn&rsquo;t, then try changing the sample code to this one:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">class Bar {};
void foo() { throw Bar(); }
</pre>
<p>Compile it like &ldquo;g++ -O0 -fno-rtti -S test.cpp&rdquo; and see the resulting file. You should see something like this now:</p>
<pre style="display: inline-block; border: 1px solid red;">_Z3foov:
    # Prologue stuff&hellip;
    # Initialize exception
    subl    $24, %esp
    movl    $1, (%esp)
    call    __cxa_allocate_exception
    movl    $0, 8(%esp)
    # Specify Bar as exception thrown
    movl    $_ZTI3Bar, 4(%esp)
    movl    %eax, (%esp)
    # Handle exception
    call    __cxa_throw
    # Epilogue stuff&hellip;
_ZTS3Bar:
    # Definition for _ZTS3Bar&hellip;
_ZTI3Bar:
    .long   _ZTVN10__cxxabiv117__class_type_infoE+8
    .long   _ZTS3Bar
    .ident  &quot;GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3&quot;
    .section    .note.GNU-stack,&quot;&quot;,@progbits
</pre>
<p>That should indeed look familiar: the class being thrown is exactly the same as the class that was used for typeid!</p>
<p>We can now conclude what&rsquo;s going on: <strong>the implementation for exception throwing type information, which needs reflexion and relies on RTTI info for it, is exactly the same as the underlying implementation for typeid and other RTTI friends</strong>. Specifying -fno-rtti on g++ only disables the &ldquo;frontend&rdquo; functions for RTTI: that means you won&rsquo;t be able to use typeid, and no RTTI classes will be generated&hellip; unless an exception is thrown, in which case the needed RTTI classes will be generated regardless of -fno-rtti being present (you still won&rsquo;t be able to access the RTTI information of this class via typeid, though).</p>
<hr />
<hr />
<p>Blog built @ 2024-02-04</p>