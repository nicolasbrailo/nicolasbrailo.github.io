<h1>Cool C++0X features XII: type inference with auto<a name="coolc0xfeaturesxiitypeinferencewithauto"></a></h1>
<p>In the last four entries we worked on a simple example, like the one I&rsquo;m pasting below, of type inference with decltype, which led us to learn about <a href="/blog/2011/0607_CoolC0XfeaturesIXdelayedtypedeclaration.html">delayed type declaration</a> and <a href="/blog/2011/0610_CoolC0XfeaturesXtypeinferencewithdecltype.html">decltypes with auto</a>. This time I want to focus just on the auto keyword instead.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &amp;lt;class&hellip; Args&amp;gt;
auto wrap(Args&hellip; a) -&amp;gt; decltype( do_something(a&hellip;) ) {
    std::cout &amp;lt;&amp;lt; <strong>PRETTY_FUNCTION</strong> &amp;lt;&amp;lt; &quot;n&quot;;
    return do_something(a&hellip;);
}
</pre>
<p>We saw <a href="/blog/2011/0610_CoolC0XfeaturesXtypeinferencewithdecltype.html">last time</a> how decltype can be used in a contrived way to create a local variable without specifying its type, only how to deduce the type for this variable. Luckily, that verbose method of type declaration can be summed up in the following way:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">    int x = 2;
    int y = 3;
    decltype(x<em>y) z = x</em>y;
</pre>
<p>Should be written as:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">    int x = 2;
    int y = 3;
    auto z = x*y;
</pre>
<p>That&rsquo;s right, when you are declaring local variables it&rsquo;s easier and cleaner to just use auto. This feature isn&rsquo;t even &ldquo;in the wild&rdquo; yet, so you can&rsquo;t really predict what will people do with it, but it seems to me that limiting its use to local variables with a very short lived scope is the best strategy. We are yet to see what monstrosities the abuse of this feature will produce, and I&rsquo;m sure there will be many. Regardless of their potential to drive insane any maintainers, its best use probably comes in loops.</p>
<p>In any C++ application, you&rsquo;ll find code like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">for (FooContainer&amp;lt;Bar&amp;gt;::const_iterator i = foobar.begin(); i != foobar.end(); ++i)
</pre>
<p>This ugly code can be eliminated with something much more elegant:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">for (auto i = foobar.begin(); i != foobar.end(); ++i)
</pre>
<p>Looks nicer indeed, but we can improve it much further with other tools. We&rsquo;ll see how the next time. For the time being, let&rsquo;s see for what auto is not to be used.</p>
<p>When using auto, keep in mind it was designed to simplify the declaration of a variable with a complex or difficult to reason type, not as a replacement for other language features like templates. This is a common mistake:</p>
<p>Wrong:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void f(auto x) {
    cout &amp;lt;&amp;lt; x;
}
</pre>
<p>Less wrong:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &amp;lt;T&amp;gt;
void f(T x) {
    cout &amp;lt;&amp;lt; x;
}
</pre>
<p>It makes no sense to use auto in the place of a template, since a template means that the type will be completed later whereas auto means it should be deduced from an initializer.</p>