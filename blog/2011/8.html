<h1>Blog title<a name="blogtitle"></a></h1>
<h1>Menu<a name="menu"></a></h1>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/blog/index.html">Blog</a></li>
<li><a href="/blog/history.html">History</a></li>
</ul>
<h1>Posts for 2011 August<a name="postsfor2011august"></a></h1>
<h1>A Makefile for code coverage report with C++<a name="amakefileforcodecoveragereportwithc"></a></h1>
<p>By Nico Brailovsky @ 2011-08-30</p>
<p>So far you should know how to <a href="/blog/2011/0822_AMakefileforTDDwithC.html">use makefiles</a> and you should have a nice <a href="/blog/2011/0830_AMakefileforcodecoveragereportwithC.html">testable project</a>. Then you have everything ready to get a coverage report. Yeah, using makefiles, you guessed!</p>
<p>This time we&rsquo;ll depend on two tools, gcov and gtest. These are in Ubuntu&rsquo;s repositories, so you should have no problem getting them. I won&rsquo;t even bother to explain this makefile (not because it&rsquo;s obvious but because I don&rsquo;t really remember how it works. I wrote this over a year ago).</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.PHONY: clean coverage_report
coverage_report:
    # Reset code coverage counters and clean up previous reports
    rm -rf coverage_report
    lcov &ndash;zerocounters &ndash;directory .
    $(MAKE) COMPILE_TYPE=code_coverage &amp;amp;&amp;amp;
    $(MAKE) COMPILE_TYPE=code_coverage test
    lcov &ndash;capture &ndash;directory $(BIN_DIR)/$(OBJ_DIR)/code_coverage &ndash;base-directory . -o salida.out &amp;amp;&amp;amp;
    lcov &ndash;remove salida.out &quot;<em>usr/include</em>&quot; -o salida.out &amp;amp;&amp;amp;
    genhtml -o coverage_report salida.out
    rm salida.out
</pre>
<p>Bonus makefile target: make your code pretty:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">.PHONY: pretty
pretty:
    find -L|egrep &#x27;.(cpp|h|hh)$$&#x27;|egrep -v &#x27;svn|_Test.cpp$$&#x27; | xargs astyle &ndash;options=none
</pre>
<p>Remember to change your astyle options as needed.</p>
<p>Bonus II: Example project using gcov and gtest: <a href="https://example.net/brokenlink/2010/08/gcov_gtest_sample.tar.gz">gcov_gtest_sample.tar</a>. The irony? It doesn&rsquo;t use my common makefile, it predates it.</p>
<hr />
<h1>Thunks, correccion de offsets<a name="thunkscorrecciondeoffsets"></a></h1>
<p>By Nico Brailovsky @ 2011-08-28</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">&lt;br/&gt;  1 struct Base0 {                                            |  1 struct Base0 {&lt;br/&gt;  2         int base0;                                        |  2         int base0;&lt;br/&gt;  3 };                                                        |  3 };&lt;br/&gt;  4                                                           |  4&lt;br/&gt;  5 struct Base1_0 : Base0 {                                  |  5 struct Base1_0 {&lt;br/&gt;  6         int base1_0;                                      |  6         struct Base0 parent;&lt;br/&gt;  7 };                                                        |  7         int base1_0;&lt;br/&gt;  8                                                           |  8 };&lt;br/&gt;  9 struct Base1_1 : Base0 {                                  |  9&lt;br/&gt; 10         int base1_1;                                      | 10 struct Base1_1 {&lt;br/&gt; 11 };                                                        | 11         struct Base0 parent;&lt;br/&gt; 12                                                           | 12         int base1_1;&lt;br/&gt; 13 struct Der : Base1_0, Base1_1 {                           | 13 };&lt;br/&gt; 14         int der;                                          | 14&lt;br/&gt; 15 };                                                        | 15 struct Der {&lt;br/&gt; 16                                                           | 16         struct Base1_0 p1;&lt;br/&gt; 17 int main() {                                              | 17         struct Base1_1 p2;&lt;br/&gt; 18         extern Der<em> getder();                             | 18         int der;&lt;br/&gt; 19                                                           | 19 };&lt;br/&gt; 20         Der </em>d = getder();                                | 20&lt;br/&gt; 21         Base1_0<em> b1_0;                                    | 21 int main() {&lt;br/&gt; 22         b1_0 = d;                                         | 22         extern struct Der</em> getder();&lt;br/&gt; 23                                                           | 23         struct Der <em>d = getder();&lt;br/&gt; 24         Base1_1</em> b1_1;                                    | 24         struct Base1_0<em> b1_0;&lt;br/&gt; 25         b1_1 = d;                                         | 25         b1_0 = &amp;amp;d-&amp;gt;p1;&lt;br/&gt; 26                                                           | 26&lt;br/&gt; 27         return 0;                                         | 27         struct Base1_1</em> b1_1;&lt;br/&gt; 28 }                                                         | 28         b1_1 = (d != 0)? &amp;amp;d-&amp;gt;p2 : 0;&lt;br/&gt; 29                                                           | 29&lt;br/&gt; 30                                                           | 30         return 0;&lt;br/&gt;~                                                             | 31 }&lt;br/&gt;~                                                             | 32&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;~                                                             |~&lt;br/&gt;cpp.cpp                                     21,1-8        Todo c.c                                         32,0-1        Todo&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
</pre>
<hr />
<h1>Link: ASCII graphs, 2.0 style<a name="linkasciigraphs2.0style"></a></h1>
<p>By Nico Brailovsky @ 2011-08-25</p>
<p>Every once in a while you need to draw a graph to quickly convey some information, and you don&rsquo;t want all the hassle of opening paint, drawing whatever you want, exporting it as png, and all that stuff. Sometimes it&rsquo;s just easier to do it as ASCII art, only you don&rsquo;t want to spend hours carefully aligning pipes and dashes. For these times <a href="http://www.asciiflow.com/">Asciiflow</a> exists.</p>
<p>Give it a try, it&rsquo;s a great way to quickly generate a diagram. Just remember to use monospace fonts.</p>
<hr />
<h1>A Makefile for TDD with C++<a name="amakefilefortddwithc"></a></h1>
<p>By Nico Brailovsky @ 2011-08-22</p>
<p>So, after reading <a href="/blog/2011/0818_Makefiles.html">my post about makefiles</a> you decided that you like them but would like to add some TDD to be buzzword compliant? No problem, that&rsquo;s easy to do.</p>
<p>Assuming you use a naming convention such as this one:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">path/to/src/Object.h
path/to/src/Object.cpp
path/to/src/Object_Test.cpp
</pre>
<p>then it&rsquo;s easy to auto detect which tests should be built:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">TEST_SRCS := $(patsubst ./%, %, $(shell find -L|grep -v svn|egrep &quot;_Test.cpp$$&quot; ) )
TEST_BINS := $(addprefix ./$(BIN_DIR)/, $(patsubst %.cpp, %, $(TEST_SRCS)) )
</pre>
<p>Then we have to define a special rule with pattern matching to compile the tests:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">$(BIN_DIR)/%_Test: $(patsubst $(BIN_DIR)/%, %, %_Test.cpp ) %.cpp %.h
    @echo &quot;Making $@&quot;
    @mkdir -p $(shell dirname $@)
    g++ $(CXXFLAGS) -g3 -O0 $&amp;lt; -o $@ -lpthread -lgtest_main -lgmock $(OBJECTS) $(LDFLAGS)
</pre>
<p>and some magic to auto execute every test when we &ldquo;make test&rdquo;:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">test: $(TEST_SRCS)
    @for TEST in $(TEST_BINS); do
        make &quot;$$TEST&quot;;
        echo &quot;Execute $(TEST)&quot;;
        ./$$TEST;
    done
</pre>
<p>Everything nice and tidy for a copy &amp; paste session:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">TEST_SRCS := $(patsubst ./%, %, $(shell find -L|grep -v svn|egrep &quot;_Test.cpp$$&quot; ) )
TEST_BINS := $(addprefix ./$(BIN_DIR)/, $(patsubst %.cpp, %, $(TEST_SRCS)) )
$(BIN_DIR)/%_Test: $(patsubst $(BIN_DIR)/%, %, %_Test.cpp ) %.cpp %.h
    @echo &quot;Making $@&quot;
    @mkdir -p $(shell dirname $@)
    g++ $(CXXFLAGS) -g3 -O0 $&amp;lt; -o $@ -lpthread -lgtest_main -lgmock $(OBJECTS) $(LDFLAGS)
.PHONY: test
test: $(TEST_SRCS)
    @for TEST in $(TEST_BINS); do
        make &quot;$$TEST&quot;;
        echo &quot;Execute $(TEST)&quot;;
        ./$$TEST;
    done
</pre>
<p>Now you just need to run make test. Remember to add the proper <a href="/blog/2010/0629_Vimtipsmakethingsworkagain.html">Vim&rsquo;s mapping</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/2011/0830_AMakefileforcodecoveragereportwithC.html">Nicol&aacute;s Brailovsky » Blog Archive » A Makefile for code coverage report with C++</a> commented @ 2011-08-30T11:14:37.000+02:00:<a name="inreplytothispostnicolaacutesbrailovskyblogarchiveamakefileforcodecoveragereportwithcblog_md20110830_amakefileforcodecoveragereportwithc.mdcommented20110830t111437.0000200"></a></h2>
<p>[&hellip;] far you should know how to use makefiles and you should have a nice testable project. Then you have everything ready to get a coverage [&hellip;]</p>
<p>Original <a href="/blog/2011/0822_AMakefileforTDDwithC.html">published here</a>.</p>
<hr />
<h1>Makefiles<a name="makefiles"></a></h1>
<p>By Nico Brailovsky @ 2011-08-18</p>
<p>For open source projects, makefiles are a must. All C++ projects need them, even though cmake is strong nowadays, and even though Java has its own version (actually, several of them, but that&rsquo;s not important now) a makefile could be used.</p>
<p>Even if it is an ubiquitous build system, it is pretty much outdated nowadays, and although using its basic features is easy, mastering it is a complex task. Worst still, mastering makefiles means you&rsquo;ll probably produce write-only-code, and as makefiles are code themselves, and must therefore be maintained, this can be a nuisance to a newcomer to your project.</p>
<p>There&rsquo;s an upside to makefiles being code: they can be reused. Once you find a configuration that suits your development process, you don&rsquo;t need to write it again. I&rsquo;ll post here some of the main targets I ussually include in a common.mk. As I mentioned, it&rsquo;s mostly write-only-code, yet you may find it useful:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;"># Dependency directoy
df=$(BUILD_DIR)/$(<em>D)/$(</em>F)
$(OBJECTS): $(BUILD_DIR)/%.o: %.cpp
    @mkdir -p $(BUILD_DIR)/$(<em>D)
    $(COMPILE.cpp) -MD -o $@ $&amp;lt;
    @cp $(df).d $(df).P;
    sed -e &#x27;s/#.</em>//&#x27; -e &#x27;s/^[^:]<em>: </em>//&#x27; -e &#x27;s/ *\$$//&#x27;
        -e &#x27;/^$$/ d&#x27; -e &#x27;s/$$/ :/&#x27; &amp;lt; $(df).d &amp;gt;&amp;gt; $(df).P;
    rm -f $(df).d
$(MAIN_OBJ): $(MAIN_SRC)
    $(COMPILE.cpp) -MD -o $@ $&amp;lt;
# Binary name depends on BIN_DIR/BIN_NAME, so the call to create BIN can
# be forwarded to BIN_DIR/BIN_NAME
$(BINARY): $(BIN_DIR)/$(BINARY)
$(BIN_DIR)/$(BINARY): $(OBJECTS) $(DEPS_OBJECTS) $(MAIN_OBJ)
    @mkdir -p $(BIN_DIR)
    @# Workaround for a linker bug: if the libs are not
    @# at the end it won&#x27;t link (something to do with how the linker
    @# lists the dependencies&hellip; too long for a comment, rtfm
    g++ $(CXXFLAGS) $^ -o $(BIN_DIR)/$@ $(LDFLAGS)
    @#$(LINK.cpp) $^ -o $@
-include $(DEPENDS)
</pre>
<p>How is this used? Well, don&rsquo;t even try to understand the dependency autogeneration, it&rsquo;ll make your head explode.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">$(OBJECTS): $(BUILD_DIR)/%.o: %.cpp
</pre>
<p>This defines a rule for building .o objects; a variable named OBJECTS should be present when including this file.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">$(MAIN_OBJ): $(MAIN_SRC)
</pre>
<p>A special rule is defined for a main object (actually this is needed to compile the tests, which we&rsquo;ll do next time, since you may have a different main function).</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">$(BINARY): $(BIN_DIR)/$(BINARY)
$(BIN_DIR)/$(BINARY): $(OBJECTS) $(DEPS_OBJECTS) $(MAIN_OBJ)
</pre>
<p>And finally, a rule for to create the real binary. Next time I&rsquo;ll add some cool features for TDD to this makefile.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="http://techrights.org/2011/08/20/firefox-7-beta/">Links 20/8/2011: Linux Graphics Survey, Firefox 7 Beta | Techrights</a> commented @ 2011-08-20T08:13:24.000+02:00:<a name="inreplytothispostlinks2082011linuxgraphicssurveyfirefox7betatechrightshttptechrights.org20110820firefox7betacommented20110820t081324.0000200"></a></h2>
<p>[&hellip;] Makefiles [&hellip;]</p>
<p>Original <a href="/blog/2011/0818_Makefiles.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/2011/0822_AMakefileforTDDwithC.html">Nicol&aacute;s Brailovsky » Blog Archive » A Makefile for TDD with C++</a> commented @ 2011-08-22T09:09:05.000+02:00:<a name="inreplytothispostnicolaacutesbrailovskyblogarchiveamakefilefortddwithcblog_md20110822_amakefilefortddwithc.mdcommented20110822t090905.0000200"></a></h2>
<p>[&hellip;] after reading my post about makefiles you decided that you like them but would like to add some TDD to be buzzword compliant? No problem, [&hellip;]</p>
<p>Original <a href="/blog/2011/0818_Makefiles.html">published here</a>.</p>
<hr />
<h1>Living on a null object<a name="livingonanullobject"></a></h1>
<p>By Nico Brailovsky @ 2011-08-16</p>
<p>Check this out:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct S {
   int f(){ return 42; }
};
int main() {
   S <em>x = (S</em>) NULL;
   return x-&amp;gt;f();
}
</pre>
<p>What does this do? Does it compile? Does it crash? I&rsquo;ll give you a second.</p>
<p>Ready? It does compile, OK</p>
<p>But it doesn&rsquo;t crash.</p>
<p>Why, you may ask</p>
<p>Think about it, you must.</p>
<p>The compiler will mangle S::f and translate this into something like:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct S {};
int mangled_S_f(struct S <em>this){
   return 42;
}
int main() {
   S </em>x = (S*) NULL;
   mangled_S_f(x);
}
</pre>
<p>Now, in this new &ldquo;translated&rdquo; code, what do you think? Will it crash? It won&rsquo;t, since no one is going to dereference &ldquo;this&rdquo;. Crazy, huh? This crazy idiom also allows even crazier things, like <a href="/blog/2011/0404_NewsflashCobjectcommitssepuku.html">C++ objects committing sepuku</a></p>
<hr />
<h1>Vacations are over<a name="vacationsareover"></a></h1>
<p>By Nico Brailovsky @ 2011-08-15</p>
<p>Long time without updates. I guess I needed vacations from the blog. It was not the first time and it probably won&rsquo;t be the last one I take, but I&rsquo;m back now with another truckload of C++ ramblings and misc stuff. Like this one:</p>
<hr />