<h1>Blog title<a name="blogtitle"></a></h1>
<h1>Menu<a name="menu"></a></h1>
<ul>
<li><a href="/">Home</a></li>
<li><a href="/blog/index.html">Blog</a></li>
<li><a href="/blog/history.html">History</a></li>
</ul>
<h1>Posts for 2011 April<a name="postsfor2011april"></a></h1>
<h1>Know your history (at least in bash)<a name="knowyourhistoryatleastinbash"></a></h1>
<p>By Nico Brailovsky @ 2011-04-28</p>
<p>I always wonder why do you see so many people pressing up a bazillion times when trying to bring a command they recently typed. Just use ctrl+r and type part of the previous command, it&rsquo;ll save you many hours of pressing up.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="">Ridgeland</a> commented @ 2011-04-29T12:02:02.000+02:00:<a name="inreplytothispostridgelandcommented20110429t120202.0000200"></a></h2>
<p>in .bashrc I have an alias:
alias his=&rsquo;history | grep &rsquo;
So I use
$ his ssh
to see all the ssh command I&rsquo;ve entered.
It&rsquo;s a shorter list than history and more than [Ctrl]+r
Then !1234 to run a command again.</p>
<p>Original <a href="/blog/2011/0428_Knowyourhistoryatleastinbash.html">published here</a>.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="http://techrights.org/2011/04/30/lot-of-ubuntu-coverage/">Links 30/4/2011: Systemd and a Lot of Ubuntu Coverage | Techrights</a> commented @ 2011-04-30T13:48:04.000+02:00:<a name="inreplytothispostlinks3042011systemdandalotofubuntucoveragetechrightshttptechrights.org20110430lotofubuntucoveragecommented20110430t134804.0000200"></a></h2>
<p>[&hellip;] Know your history (at least in bash) [&hellip;]</p>
<p>Original <a href="/blog/2011/0428_Knowyourhistoryatleastinbash.html">published here</a>.</p>
<hr />
<h1>Cool C++0X features III: Variadic templates, a fix for varargs<a name="coolc0xfeaturesiiivariadictemplatesafixforvarargs"></a></h1>
<p>By Nico Brailovsky @ 2011-04-26</p>
<p><a href="/blog/2011/0419_CoolC0XfeaturesIIVariadictemplatesWhat39swrongwithvarargs.html">Last time</a> we saw why a function with varargs may bring lots of problems. Then we saw how to solve it, but never explained why that last solution doesn&rsquo;t have the problems the varargs solution had, nor how does it work. Let&rsquo;s start by copying the solution here:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">// Stop condition
void println() {}
// General case
template &amp;lt;typename H, typename&hellip; T&amp;gt;
void println(H p, T&hellip; t)
{
   std::cout &amp;lt;&amp;lt; p;
   println(t&hellip;);
}
int main() {
   println(&quot;Hola&quot;, &quot; mundo &quot;, 42, &#x27;n&#x27;;);
   return 0;
}
</pre>
<p>It certainly looks much better than the varargs function, even though some new strange syntax has been introduced. Keep in mind some <a href="/search/label/Templates">template-foo</a> is required, not only because of the syntax but because we&rsquo;ll be talking about functional programming too.</p>
<p>With all that intro (the last 2 articles were just an intro!) now we are in a good shape to ask what a variadic template really is. In its easiest form, it&rsquo;s just a list of template arguments, like this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &amp;lt;typename&hellip; T&amp;gt; void foo(T&hellip; t) {}
</pre>
<p>That simple template can accept as many parameters as you need, of any type. This is much safer than a vararg because:
* Doesn&rsquo;t require the user to specify the number of args passed to foo, so it just can&rsquo;t get out of sync
* It&rsquo;s typesafe; since C++ templates are type-safe, variadic templates are type safe too. You won&rsquo;t be able to request an int where a char is required, you&rsquo;ll just get a compiler error.
* Compile time check: you get type safety just because this is all compiled code. If it doesn&rsquo;t compile, you get an error (albeit a little cryptic).
* <a href="/blog/2010/0407_PODtypesinC.html">POD types</a> support
* Better performance; small gain, but a gain indeed. Since this is all done in compile time there&rsquo;s no need to handle the stack dynamically, nor of having a loop getting the args. It&rsquo;s all known when you compile, thus the compiler can just optimize the hell out of everything</p>
<p>Pretty neat, huh? But how does it work? Variadic templates are actually very similar to how Haskell handles lists, you get all the arguments as a list of types in which you can either get the head or the tail. To do something useful, get the head and continue processing the tail recursively.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &amp;lt;typename H, typename&hellip; T&amp;gt;
void do_something(H h, T&hellip; t)
{
    // Do something useful with h
    really_do_something(h);
    // Continue processing the tail
    do_something(t&hellip;);
}
</pre>
<p>Of course, you&rsquo;ll eventually need a condition to stop processing: (we&rsquo;ll explain the new syntax later)</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void do_something()
{
    // Do nothing :)
}
</pre>
<p>When the list is completely processed the empty do_something function will be called. Easy, right? But it does have a lot of weird syntax. Let&rsquo;s see what each of those ellipses mean:</p>
<ul>
<li>When declaring typename&hellip; T you are saying &ldquo;here goes a list of types&rdquo;. That is, when you use ellipses after the typename (or class) declaration but before the name of the type, then you are expecting a list of types there.</li>
<li>When declaring T&hellip; t you are saying t is a list of objects with different type. That is, you declared T&hellip; as a type which holds a list of types, therefore t, of type T, is an instance of a list of objects, each of different type</li>
<li>When you write t&hellip;, you are saying &ldquo;expand the list of arguments&rdquo;. You declared t as a list of objects, but you have no way of accessing each of those objects, just to the list as a whole. When you write the name of the object followed by ellipses, you are saying expand these types and their instance for the called function</li>
</ul>
<p>With all that in mind, let&rsquo;s put together our typesafe printf:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">// Condition to stop processing
void println() {}
// Println receives a list of arguments. We don&amp;#x27;t know it&amp;#x27;s type nor
// how many there are, so we just get the head and expand the rest
template &amp;lt;typename H, typename&hellip; T&amp;gt;
void println(H p, T&hellip; t)
{
    // Do something useful with the head
    std::cout &amp;lt;&amp;lt; p;
    // Expand the rest (pass it recursively to println)
    println(t&hellip;);
}
int main() {
    // See how it works even better than varargs?
   println(&quot;Hola&quot;, &quot; mundo &quot;, 42, &amp;#x27;n&amp;#x27;);
   return 0;
}
</pre>
<p>Next time, we&rsquo;ll see a more complex (and fun) example of variadic templates.</p>
<hr />
<h1>echo &ldquo;Hola mundo&rdquo; &gt; /dev/full<a name="echoholamundodevfull"></a></h1>
<p>By Nico Brailovsky @ 2011-04-21</p>
<p>I&rsquo;d write something witty but there&rsquo;s not a lot to talk about /dev/full. Anyway, it is a cool tip, so I&rsquo;ll share it:</p>
<blockquote>
<p>Everyone knows /dev/null, and most will know /dev/zero. But /dev/full was unknown to me until some time ago. This device will respond to any write request with ENOSPC, No space left on device. Handy if you want to test if your program catches &ldquo;disk full&rdquo; - just let it write there</p>
</blockquote>
<p>From <a href="http://www.df7cb.de/blog/2010/dev_full.html">Myon&rsquo;s Blog</a></p>
<hr />
<h1>Cool C++0X features II, Variadic templates: What&#39;s wrong with varargs<a name="coolc0xfeaturesiivariadictemplateswhat39swrongwithvarargs"></a></h1>
<p>By Nico Brailovsky @ 2011-04-19</p>
<p><a href="/blog/2011/0418_CoolC0XfeaturesIIntro.html">Last time</a> we explained what variadic templates are. We&rsquo;ll see what they can do now. We mentioned that solving the problem of having a type-safe varargs is one of the best ways of applying variadic templates, but what&rsquo;s varargs?</p>
<p>Varargs functions (from C world, not even from C++!) are functions which have a variable number of arguments, just like printf. These are usually very dangerous functions, since they are not typesafe. Let&rsquo;s see how they are implemented with an example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;stdarg.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
// My god, it&#x27;s full of bugs
void va_println(int args_left, &hellip;) {
   va_list arg_lst;
   va_start(arg_lst, args_left);
   while(args_left&ndash;) {
      const char <em>p = va_arg(arg_lst, const char</em>);
      std::cout &amp;lt;&amp;lt; p;
   }
   va_end(arg_lst);
}
int main() {
   va_println(3, &quot;Hola &quot;, &quot;mundo&quot;, &quot;n&quot;);
   return 0;
}
</pre>
<p>This implementation of a function with variable arguments is, more or less, the best C can give us, yet it riddled with bugs and hidden problems. Let&rsquo;s go one by one:</p>
<ul>
<li><strong>Arg num will get out of sync</strong>: You need to specify the list of args as well as how many you have. That WILL get out of sync. Trust me, it&rsquo;s just a mater of time. And when it does, you&rsquo;ll have a coredump.</li>
<li><strong>Type-unsafe</strong>: You just tell varargs &ldquo;Hey, get me an int&rdquo;. And it will give you an int, no warranties included. If it was supposed to be a short instead, though luck, you end up with a coredump.</li>
<li><strong>No, really, coredump</strong>: Where are so many coredumps coming from, you may ask. Easy, varargs it&rsquo;s just a way of handling the stack. Calling va_arg just moves the stack pointer by the sizeof the datatype you requested. That means no compile-time checks are included.</li>
<li><strong>No pod types</strong>: Remember POD types? Try running this code:</li>
</ul>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">#include &amp;lt;stdarg.h&amp;gt;
struct X { virtual ~X(){} };
void va_println(int args_left, &hellip;) {
   va_list arg_lst;
   va_start(arg_lst, args_left);
   while(args_left&ndash;) {
      X <em>p = va_arg(arg_lst, X</em>);
   }
   va_end(arg_lst);
}
int main() {
   X x, y, z;
   va_println(3, x, y, z);
   return 0;
}
</pre>
<h3>And how do we fix it?<a name="andhowdowefixit"></a></h3>
<p>The fix is easy. Too easy. You just need C++0X. We will discuss why this is better next time, but just as a sneak peak:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void println() {}
template &amp;lt;typename H, typename&hellip; T&amp;gt; void println(H p, T&hellip; t) {
   std::cout &amp;lt;&amp;lt; p;
   println(t&hellip;);
}
int main() {
   println(&quot;Hola&quot;, &quot; mundo &quot;, 42, &amp;#x27;n&amp;#x27;);
   return 0;
}
</pre>
<p>Remember to compile using -std=c++0x in gcc.</p>
<p><strong>(Thanks Hugo Arregui for correcting the POD example)</strong></p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="">Matthew Fioravante</a> commented @ 2015-09-03T22:38:03.000+02:00:<a name="inreplytothispostmatthewfioravantecommented20150903t223803.0000200"></a></h2>
<p>&ldquo;Type-unsafe: You just tell varargs &ldquo;Hey, get me an int&rdquo;. And it will give you an int, no warranties included. If it was supposed to be a short instead, though luck, you end up with a coredump.&rdquo;</p>
<p>While the concept is true in general, your exact example is not exactly right. Variadic functions perform integral promotion on all of the arguments. So if you pass a short you have to read it back out using va_arg(vl, int).</p>
<p>If however you pass a short and then do va_arg(vl, short), you could be triggering undefined behavior.. Similarly with char and the unsigned variants which all get promoted to int.</p>
<p>More reasons not to use variadic functions&hellip;</p>
<p>Original <a href="/blog/2011/0419_CoolC0XfeaturesIIVariadictemplatesWhat39swrongwithvarargs.html">published here</a>.</p>
<hr />
<h1>Cool C++0X features I: Intro<a name="coolc0xfeaturesiintro"></a></h1>
<p>By Nico Brailovsky @ 2011-04-18</p>
<p>C++0X brings some very cool changes, and I wanted to start a series of posts regarding some of these changes, with a small explanation of each new feature (that I currently understand, at least), an example of its usage and why I think it&rsquo;s a cool thing. Notice these two may be mutually exclusive, some of these may just be cool but I wouldn&rsquo;t recommend using them on a day to day basis. An example of a very cool feature which I wouldn&rsquo;t normally use in a project is the one I want to write about today: variadic templates.</p>
<p>What&rsquo;s not to love about variadic templates? Its name implies (correctly) that it uses templates, and it also has a &ldquo;variadic&rdquo; thingy, which you can use to look smart since no one really knows what it means.</p>
<p>Templates themselves can quickly get complicated if used by unexperienced padawans in the art of martial C++, yet their hypnotic beauty draws every programmer to use them just like flies are drawn to fire. When used correctly they can produce very elegant code; if not for the template programmer, at least for the end user. Yet in all their power, templates in C++ have been lacking a fundamental aspect: a variable number of arguments.</p>
<p>There are ways to work around this limitation, like using a list of types paired with a template-paramlist-object. Sounds familiar? (I know it doesn&rsquo;t, don&rsquo;t worry). You could also generate N constructors, one overload for each parameter count. The drawback, exponential compile time (say, TR1). These are all hacks, which are in place only because there wasn&rsquo;t a safe way of passing a list of types associated with a list of arguments. This is over now with variadic templates in C++0X.</p>
<p>So, what kind of problem would variadic templates solve? Let&rsquo;s name a few:
* A typesafe varargs function (a function with a variable number of arguments)
* Easily create a template object which acts as a tuple
* An easier implementation of a reduce (inject) function</p>
<p>This entry is getting quite long so we&rsquo;ll start seeing these examples on the next post.</p>
<hr />
<h1>Hex dump in C++<a name="hexdumpinc"></a></h1>
<p>By Nico Brailovsky @ 2011-04-07</p>
<p>If you need to work with low level stuff (say communications protocols, compression algorithms, stuff like that) you&rsquo;ll be needing an hex dump function sooner or later. Alex, from <a href="http://www.alexonlinux.com/">Alex on Linux</a>, has a great <a href="http://www.alexonlinux.com/hex-dump-functions">hex dump function</a> for Python and C.</p>
<p>I added an =NULL for caption, I don&rsquo;t use it.</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void hex_dump(char <em>data, int size, char </em>caption=NULL)
{
    int i; // index in data&hellip;
    int j; // index in line&hellip;
    char temp[8];
    char buffer[128];
    char *ascii;
    memset(buffer, 0, 128);
    printf(&quot;---------&amp;gt; %s &amp;lt;--------- (%d bytes from %p)n&quot;, caption, size, data);
    // Printing the ruler&hellip;
    printf(&quot;        +0          +4          +8          +c            0   4   8   c   n&quot;);
    // Hex portion of the line is 8 (the padding) + 3 * 16 = 52 chars long
    // We add another four bytes padding and place the ASCII version&hellip;
    ascii = buffer + 58;
    memset(buffer, &amp;#x27; &amp;#x27;, 58 + 16);
    buffer[58 + 16] = &amp;#x27;n&amp;#x27;;
    buffer[58 + 17] = &amp;#x27;&amp;#x27;;
    buffer[0] = &amp;#x27;+&amp;#x27;;
    buffer[1] = &amp;#x27;0&amp;#x27;;
    buffer[2] = &amp;#x27;0&amp;#x27;;
    buffer[3] = &amp;#x27;0&amp;#x27;;
    buffer[4] = &amp;#x27;0&amp;#x27;;
    for (i = 0, j = 0; i &amp;lt; size; i++, j++)
    {
        if (j == 16)
        {
            printf(&quot;%s&quot;, buffer);
            memset(buffer, &amp;#x27; &amp;#x27;, 58 + 16);
            sprintf(temp, &quot;+%04x&quot;, i);
            memcpy(buffer, temp, 5);
            j = 0;
        }
        sprintf(temp, &quot;%02x&quot;, 0xff &amp;amp; data[i]);
        memcpy(buffer + 8 + (j * 3), temp, 2);
        if ((data[i] &amp;gt; 31) &amp;amp;&amp;amp; (data[i] &amp;lt; 127))
            ascii[j] = data[i];
        else
            ascii[j] = &amp;#x27;.&amp;#x27;;
    }
    if (j != 0)
        printf(&quot;%s&quot;, buffer);
}
</pre>
<hr />
<h1>Newsflash: C++ object commits sepuku<a name="newsflashcobjectcommitssepuku"></a></h1>
<p>By Nico Brailovsky @ 2011-04-04</p>
<p>Check this out. Is it valid C++?</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">class X {
  void dispose() {
    delete this;
  }
};
</pre>
<p>Strange pattern, isn&rsquo;t it?. What happens if you try to dispose a heap object?</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void f() {
   X x;
   x.dispose();
}
</pre>
<p>Indeed, nasal demons FTW, you&rsquo;re trying to free an invalid pointer. Yet if we change that a little bit&hellip;</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">void f() {
   (new X)-&amp;gt;dispose();
}
</pre>
<p>Zomg now it works. It&rsquo;s weird, but it works. Why would anybody on earth do something like this? Can you guess when would this be useful?</p>
<p>Some times you launch a background job, and you don&rsquo;t really care when it&rsquo;s done. You may use a <a href="/blog/2009/0803_CMagiccallbackssolved.html">callback</a> to be notified when the job is done, but if you don&rsquo;t really care then having an object which deletes itself is an option. You&rsquo;ll have to be very careful about it, though, because this is legal C++ too:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">class X {
  void dispose() {
    delete this;
    std::cout &amp;lt;&amp;lt; &quot;Hello worldn&quot;;
  }
};
</pre>
<p>Though &ldquo;Hello world&rdquo; will be printed, it will be running in a dead object. Which is fine, as far as the compiler cares, but if you do try to reference the this pointer, you&rsquo;ll be in a lot of trouble.</p>
<p><strong>Bonus reading</strong>
For a much more interesting note than mine, go and check <a href="http://blogs.msdn.com/b/oldnewthing/archive/2010/08/10/10048149.aspx">When does an object become available for garbage collection?</a> in The Old New Thing.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/2011/0816_Livingonanullobject.html">Nicol&aacute;s Brailovsky » Blog Archive » Living on a null object</a> commented @ 2011-08-16T09:05:04.000+02:00:<a name="inreplytothispostnicolaacutesbrailovskyblogarchivelivingonanullobjectblog_md20110816_livingonanullobject.mdcommented20110816t090504.0000200"></a></h2>
<p>[&hellip;] Now, in this new &ldquo;translated&rdquo; code, what do you think? Will it crash? It won’t, since no one is going to dereference &ldquo;this&rdquo;. Crazy, huh? This crazy idiom also allows even crazier things, like C++ objects committing sepuku [&hellip;]</p>
<p>Original <a href="/blog/2011/0404_NewsflashCobjectcommitssepuku.html">published here</a>.</p>
<hr />