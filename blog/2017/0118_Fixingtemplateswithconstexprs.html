<h1>Fixing templates with constexpr&rsquo;s<a name="fixingtemplateswithconstexprs"></a></h1>
<p>For my hundredth (and a bit) c++ post I decided to do something I never did before: fix my old code!</p>
<p>A long time ago I wrote about template metaprogramming devices. There, I tried to explain that many atrocities have been commited in the name of performance and &ldquo;compile time evaluation&rdquo;. Template metaprogramming is probably one of the worse culprits of job security. Its (ab)use can create monstrosities, all in the name of runtime performance. Like, for example, my <a href="/search/label/Series%3A Template Metaprogramming">template device to calculate e</a>. Let&rsquo;s remember what that atrocious code looks like (follow the link if you want an explanation on how this works):</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">template &amp;lt;int N, int D&amp;gt; struct Frak {
        static const long Num = N;
        static const long Den = D;
};
template &amp;lt;int N, typename F&amp;gt; struct ScalarMultiplication {
    typedef Frak&amp;lt;N<em>F::Num, N</em>F::Den&amp;gt; result;
};
template &amp;lt;int X, int Y&amp;gt; struct MCD {
        static const long result = MCD&amp;lt;Y, X % Y&amp;gt;::result;
};
template &amp;lt;int X&amp;gt; struct MCD&amp;lt;X, 0&amp;gt; {
        static const long result = X;
};
template &amp;lt;class F&amp;gt; struct Simpl {
        static const long mcd = MCD&amp;lt;F::Num, F::Den&amp;gt;::result;
        typedef Frak&amp;lt; F::Num / mcd, F::Den / mcd &amp;gt; result;
};
template &amp;lt;typename X1, typename Y1&amp;gt; struct SameBase {
    typedef typename ScalarMultiplication&amp;lt; Y1::Den, X1&amp;gt;::result X;
    typedef typename ScalarMultiplication&amp;lt; X1::Den, Y1&amp;gt;::result Y;
};
template &amp;lt;typename X, typename Y&amp;gt; struct Sum {
    typedef SameBase&amp;lt;X, Y&amp;gt; B;
    static const long Num = B::X::Num + B::Y::Num;
    static const long Den = B::Y::Den; // == B::X::Den
    typedef typename Simpl&amp;lt; Frak&amp;lt;Num, Den&amp;gt; &amp;gt;::result result;
};
template &amp;lt;int N&amp;gt; struct Fact {
    static const long result = N * Fact&amp;lt;N-1&amp;gt;::result;
};
template &amp;lt;&amp;gt; struct Fact&amp;lt;0&amp;gt; {
    static const long result = 1;
};
template &amp;lt;int N&amp;gt; struct E {
    // e = S(1/n!) = 1/0! + 1/1! + 1/2! + &hellip;
    static const long Den = Fact&amp;lt;N&amp;gt;::result;
    typedef Frak&amp;lt; 1, Den &amp;gt; term;
    typedef typename E&amp;lt;N-1&amp;gt;::result next_term;
    typedef typename Sum&amp;lt; term, next_term &amp;gt;::result result;
};
template &amp;lt;&amp;gt; struct E&amp;lt;0&amp;gt; {
    typedef Frak&amp;lt;1, 1&amp;gt; result;
};
int main() {
  typedef E&amp;lt;8&amp;gt;::result X;
  std::cout &amp;lt;&amp;lt; &quot;e = &quot; &amp;lt;&amp;lt; (1.0 * X::Num / X::Den) &amp;lt;&amp;lt; &quot;\n&quot;;
  std::cout &amp;lt;&amp;lt; &quot;e = &quot; &amp;lt;&amp;lt; X::Num &amp;lt;&amp;lt;&quot;/&quot;&amp;lt;&amp;lt; X::Den &amp;lt;&amp;lt; &quot;\n&quot;;
  return 0;
}
</pre>
<p>While this is just a toy example to play with templates, it does illustrate code I&rsquo;ve seen in the wild. Would this look cleaner in c++11? Yes, it would. Constexprs are, in my opinion, one of the most overlooked &ldquo;killer&rdquo; features of c++11.</p>
<p>Starting with a simple example:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">constexpr int foo(int a, int b) { return a+b; }
static constexpr int n = foo(1, 2);
int bar() { return n; }
</pre>
<p>Try to compile it with &ldquo;g++ -std=c++11 -fverbose-asm -O0 -c -S -o /dev/stdout&rdquo; and see what happens. You should get the equivalent of &ldquo;return 3&rdquo; - just as anyone would expect - but note that no optimizations were enabled. What about loops? Let&rsquo;s try this:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">constexpr int f(int n) {
    return (n&amp;lt;2)? 1 : n + f(n-1);
}
constexpr int n = f(999);
</pre>
<p>You&rsquo;ll probably get an error about maximum depth exceeded, but that&rsquo;s alright: we have loops in constexprs too! (note that some of these restrictions have been relaxed in C++17).</p>
<p>In general, if you can express your function as a single const return statement, it should be a valid constexpr. With this new knowledge, let&rsquo;s convert the template meta-atrocity above to something a bit less hideous:</p>
<pre lang="c++" style="display: inline-block; border: 1px solid red;">struct PodFrac {
    int num;
    int den;
};
constexpr int mcd(int a, int b) {
    return (b==0)? a : mcd(b, a%b);
}
constexpr PodFrac simpl(const PodFrac &amp;amp;f) {
    return PodFrac{f.num / mcd(f.num, f.den), f.den / mcd(f.num, f.den)};
}
constexpr PodFrac sum(const PodFrac &amp;amp;a, const PodFrac &amp;amp;b) {
    return simpl(PodFrac{a.num<em>b.den + b.num</em>a.den, a.den<em>b.den});
}
constexpr int fact(int n) {
    return (n==0)? 1 : n</em>fact(n-1);
}
constexpr PodFrac e(int n) {
    return (n==0)? PodFrac{1, 1} :
                   sum(PodFrac{1, fact(n)}, e(n-1));
}
constexpr float e_num = 1.0 * e(8).num / e(8).den;
float get_e() {
    return e_num;
}
</pre>
<p>Disclaimer: while I explicitly stated this multiple times in my &ldquo;<a href="/search/label/Series%3A Template Metaprogramming">C++ template metaprogramming introduction</a>&rdquo; article, it&rsquo;s worth re-stating it: this code is meant as an example to showcase a c++ feature, not as a proper way of deriving a mathematical constant in production code.</p>
<p>First thoughts after comparing the two versions: much, much [, much]*100 cleaner.</p>
<p>As you may notice, all constexprs need to be a return statement. There&rsquo;s no multi-statement constexpr in c++11, which explains why loops are not really supported. For the same reason the implementation of e() is a bit hindered by this limitation: its code would be much more readable splitting it in a few lines with proper names. Good news: some of these restrictions have been relaxed in C++17.</p>
<p>Note that if you analyze your compiler&rsquo;s output when building without optimizations, you may see either a const with e&rsquo;s value, or a static initializer that does some trivial operation, like loading e&rsquo;s value from a fraction: gcc seems to get tired of constexpr evaluation after a few recursive calls, so your results may vary (slightly).</p>
<p>I called constexpr&rsquo;s one of c++11&rsquo;s killer features, and hopefully you can see why I&rsquo;m so enthusiastic about them now: there&rsquo;s much less incentive for people to write horrible template metaprogramming devices when simply adding a little keyword to a normal function has the same effect, only cleaner.</p>
<hr />
<h2>In reply to <a href="">this post</a>, <a href="/blog/youfoundadeadlink.html">Fixing templates with constexpr’s | patwanjau</a> commented @ 2017-01-19T13:01:02.000+01:00:<a name="inreplytothispostfixingtemplateswithconstexprspatwanjaublog_mdyoufoundadeadlink.mdcommented20170119t130102.0000100"></a></h2>
<p>[&hellip;] Source: Fixing templates with constexpr’s [&hellip;]</p>
<p>Original <a href="/blog/2017/0118_Fixingtemplateswithconstexprs.html">published here</a>.</p>